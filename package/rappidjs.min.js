
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.0.0 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
/*jslint regexp: true, nomen: true */
/*global window, navigator, document, importScripts, jQuery, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    

    var version = '2.0.0',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        ostring = Object.prototype.toString,
        ap = Array.prototype,
        aps = ap.slice,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false,
        req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return obj.hasOwnProperty(prop);
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     * This is not robust in IE for transferring methods that match
     * Object.prototype names, but the uses of mixin here seem unlikely to
     * trigger a problem related to that.
     */
    function mixin(target, source, force) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    target[prop] = value;
                }
            });
        }
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    //Allow getting a global that expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    function makeContextModuleFunc(func, relMap, enableBuildCallback) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0), lastArg;
            if (enableBuildCallback &&
                isFunction((lastArg = args[args.length - 1]))) {
                lastArg.__requireJsBuild = true;
            }
            args.push(relMap);
            return func.apply(null, args);
        };
    }

    function addRequireMethods(req, context, relMap) {
        each([
            ['toUrl'],
            ['undef'],
            ['defined', 'requireDefined'],
            ['specified', 'requireSpecified']
        ], function (item) {
            req[item[0]] = makeContextModuleFunc(context[item[1] || item[0]], relMap);
        });
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite and existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var config = {
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {}
            },
            registry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlMap = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1,
            //Used to track the order in which modules
            //should be executed, by the order they
            //load. Important for consistent cycle resolution
            //behavior.
            waitAry = [],
            inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var baseParts = baseName && baseName.split('/'),
                map = config.map,
                starMap = map && map['*'],
                pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap;

            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    if (config.pkgs[baseName]) {
                        //If the baseName is a package name, then just treat it as one
                        //name to concat the name with.
                        baseParts = [baseName];
                    } else {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that 'directory' and not name of the baseName's
                        //module. For instance, baseName of 'one/two/three', maps to
                        //'one/two/three.js', but we want the directory, 'one/two' for
                        //this normalization.
                        baseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = baseParts.concat(name.split('/'));
                    trimDots(name);

                    //Some use of packages may use a . path to reference the
                    //'main' module name, so normalize for that.
                    pkgConfig = config.pkgs[(pkgName = name[0])];
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if (applyMap && (baseParts || starMap) && map) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = map[baseParts.slice(0, j).join('/')];

                            //baseName segment has  config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = mapValue[nameSegment];
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    break;
                                }
                            }
                        }
                    }

                    if (!foundMap && starMap && starMap[nameSegment]) {
                        foundMap = starMap[nameSegment];
                    }

                    if (foundMap) {
                        nameParts.splice(0, i, foundMap);
                        name = nameParts.join('/');
                        break;
                    }
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = config.paths[id];
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                removeScript(id);
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.undef(id);
                context.require([id]);
                return true;
            }
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var index = name ? name.indexOf('!') : -1,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName, url, pluginModule, suffix;

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            if (index !== -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    pluginModule = defined[prefix];
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    url = urlMap[normalizedName];
                    if (!url) {
                        //Calculate url for the module, if it has a name.
                        //Use name here since nameToUrl also calls normalize,
                        //and for relative names that are outside the baseUrl
                        //this causes havoc. Was thinking of just removing
                        //parentModuleMap to avoid extra normalization, but
                        //normalize() still does a dot removal because of
                        //issue #142, so just pass in name here and redo
                        //the normalization. Paths outside baseUrl are just
                        //messy to support.
                        url = context.nameToUrl(name, null, parentModuleMap);

                        //Store the URL mapping for later.
                        urlMap[normalizedName] = url;
                    }
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                    prefix + '!' + (normalizedName || '') :
                    normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = registry[id];

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = registry[id];

            if (hasProp(defined, id) &&
                (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                getModule(depMap).on(name, fn);
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = registry[id];
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        /**
         * Helper function that creates a require function object to give to
         * modules that ask for it as a dependency. It needs to be specific
         * per module because of the implication of path mappings that may
         * need to be relative to the module name.
         */
        function makeRequire(mod, enableBuildCallback, altRequire) {
            var relMap = mod && mod.map,
                modRequire = makeContextModuleFunc(altRequire || context.require,
                                                   relMap,
                                                   enableBuildCallback);

            addRequireMethods(modRequire, context, relMap);

            return modRequire;
        }

        handlers = {
            'require': function (mod) {
                return makeRequire(mod);
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    return (mod.exports = defined[mod.map.id] = {});
                }
            },
            'module': function (mod) {
                return (mod.module = {
                    id: mod.map.id,
                    uri: mod.map.url,
                    config: function () {
                        return (config.config && config.config[mod.map.id]) || {};
                    },
                    exports: defined[mod.map.id]
                });
            }
        };

        function removeWaiting(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];

            each(waitAry, function (mod, i) {
                if (mod.map.id === id) {
                    waitAry.splice(i, 1);
                    if (!mod.defined) {
                        context.waitCount -= 1;
                    }
                    return true;
                }
            });
        }

        function findCycle(mod, traced) {
            var id = mod.map.id,
                depArray = mod.depMaps,
                foundModule;

            //Do not bother with unitialized modules or not yet enabled
            //modules.
            if (!mod.inited) {
                return;
            }

            //Found the cycle.
            if (traced[id]) {
                return mod;
            }

            traced[id] = true;

            //Trace through the dependencies.
            each(depArray, function (depMap) {
                var depId = depMap.id,
                    depMod = registry[depId];

                if (!depMod) {
                    return;
                }

                if (!depMod.inited || !depMod.enabled) {
                    //Dependency is not inited, so this cannot
                    //be used to determine a cycle.
                    foundModule = null;
                    delete traced[id];
                    return true;
                }

                return (foundModule = findCycle(depMod, traced));
            });

            return foundModule;
        }

        function forceExec(mod, traced, uninited) {
            var id = mod.map.id,
                depArray = mod.depMaps;

            if (!mod.inited || !mod.map.isDefine) {
                return;
            }

            if (traced[id]) {
                return defined[id];
            }

            traced[id] = mod;

            each(depArray, function(depMap) {
                var depId = depMap.id,
                    depMod = registry[depId],
                    value;

                if (handlers[depId]) {
                    return;
                }

                if (depMod) {
                    if (!depMod.inited || !depMod.enabled) {
                        //Dependency is not inited,
                        //so this module cannot be
                        //given a forced value yet.
                        uninited[id] = true;
                        return;
                    }

                    //Get the value for the current dependency
                    value = forceExec(depMod, traced, uninited);

                    //Even with forcing it may not be done,
                    //in particular if the module is waiting
                    //on a plugin resource.
                    if (!uninited[depId]) {
                        mod.defineDepById(depId, value);
                    }
                }
            });

            mod.check(true);

            return defined[id];
        }

        function modCheck(mod) {
            mod.check();
        }

        function checkLoaded() {
            var waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                stillLoading = false,
                needCycleCheck = true,
                map, modId, err, usingPathFallback;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(registry, function (mod) {
                map = mod.map;
                modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {

                each(waitAry, function (mod) {
                    if (mod.defined) {
                        return;
                    }

                    var cycleMod = findCycle(mod, {}),
                        traced = {};

                    if (cycleMod) {
                        forceExec(cycleMod, traced, {});

                        //traced modules may have been
                        //removed from the registry, but
                        //their listeners still need to
                        //be called.
                        eachProp(traced, modCheck);
                    }
                });

                //Now that dependencies have
                //been satisfied, trigger the
                //completion check that then
                //notifies listeners.
                eachProp(registry, modCheck);
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = undefEvents[map.id] || {};
            this.map = map;
            this.shim = config.shim[map.id];
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function(depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                each(depMaps, bind(this, function (depMap, i) {
                    if (typeof depMap === 'string') {
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               true);
                        this.depMaps.push(depMap);
                    }

                    var handler = handlers[depMap.id];

                    if (handler) {
                        this.depExports[i] = handler(this);
                        return;
                    }

                    this.depCount += 1;

                    on(depMap, 'defined', bind(this, function (depExports) {
                        this.defineDep(i, depExports);
                        this.check();
                    }));

                    if (errback) {
                        on(depMap, 'error', errback);
                    }
                }));

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDepById: function (id, depExports) {
                var i;

                //Find the index for this dependency.
                each(this.depMaps, function (map, index) {
                    if (map.id === id) {
                        i = index;
                        return true;
                    }
                });

                return this.defineDep(i, depExports);
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (map.prefix) {
                    this.callPlugin();
                } else if (this.shim) {
                    makeRequire(this, true)(this.shim.deps || [], bind(this, function () {
                        this.load();
                    }));
                } else {
                    //Regular dependency.
                    this.load();
                }
            },

            load: function() {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks is the module is ready to define itself, and if so,
             * define it. If the silent argument is true, then it will just
             * define, but not notify listeners, and not ask for a context-wide
             * check of all loaded modules. That is useful for cycle breaking.
             */
            check: function (silent) {
                if (!this.enabled) {
                    return;
                }

                var id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory,
                    err, cjsModule;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error.
                            if (this.events.error) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                //If setting exports via 'module' is in play,
                                //favor that over return value and exports. After that,
                                //favor a non-undefined return value over exports use.
                                cjsModule = this.module;
                                if (cjsModule &&
                                    cjsModule.exports !== undefined &&
                                    //Make sure it is not already the exports value
                                    cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = [this.map.id];
                                err.requireType = 'define';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        delete registry[id];

                        this.defined = true;
                        context.waitCount -= 1;
                        if (context.waitCount === 0) {
                            //Clear the wait array used for cycles.
                            waitAry = [];
                        }
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (!silent) {
                        if (this.defined && !this.defineEmitted) {
                            this.defineEmitted = true;
                            this.emit('defined', this.exports);
                            this.defineEmitComplete = true;
                        }
                    }
                }
            },

            callPlugin: function() {
                var map = this.map,
                    id = map.id,
                    pluginMap = makeModuleMap(map.prefix, null, false, true);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        load, normalizedMap, normalizedMod;

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            });
                        }

                        normalizedMap = makeModuleMap(map.prefix + '!' + name);
                        on(normalizedMap,
                           'defined', bind(this, function (value) {
                            this.init([], function () { return value; }, null, {
                                enabled: true,
                                ignore: true
                            });
                        }));
                        normalizedMod = registry[normalizedMap.id];
                        if (normalizedMod) {
                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                removeWaiting(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = function (moduleName, text) {
                        /*jslint evil: true */
                        var hasInteractive = useInteractive;

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        req.exec(text);

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Support anonymous modules.
                        context.completeLoad(moduleName);
                    };

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, makeRequire(map.parentMap, true, function (deps, cb) {
                        return context.require(deps, cb);
                    }), load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                this.enabled = true;

                if (!this.waitPushed) {
                    waitAry.push(this);
                    context.waitCount += 1;
                    this.waitPushed = true;
                }

                //Enable each dependency
                each(this.depMaps, bind(this, function (map) {
                    var id = map.id,
                        mod = registry[id];
                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!handlers[id] && mod && !mod.enabled) {
                        context.enable(map, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = registry[pluginMap.id];
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.check();
            },

            on: function(name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry/waitAry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        return (context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlMap: urlMap,
            urlFetched: urlFetched,
            waitCount: 0,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths and packages since they require special processing,
                //they are additive.
                var paths = config.paths,
                    pkgs = config.pkgs,
                    shim = config.shim,
                    map = config.map || {};

                //Mix in the config values, favoring the new values over
                //existing ones in context.config.
                mixin(config, cfg, true);

                //Merge paths.
                mixin(paths, cfg.paths, true);
                config.paths = paths;

                //Merge map
                if (cfg.map) {
                    mixin(map, cfg.map, true);
                    config.map = map;
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if (value.exports && !value.exports.__buildReady) {
                            value.exports = context.makeShimExports(value.exports);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;

                        //Create a brand new object on pkgs, since currentPackages can
                        //be passed in again, and config.pkgs is the internal transformed
                        //state for all package configs.
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            //Remove leading dot in main, so main paths are normalized,
                            //and remove any trailing .js, since different package
                            //envs have different conventions: some use a module name,
                            //some use a file name.
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });

                    //Done with modifications, assing packages back to context config
                    config.pkgs = pkgs;
                }

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (exports) {
                var func;
                if (typeof exports === 'string') {
                    func = function () {
                        return getGlobal(exports);
                    };
                    //Save the exports for use in nodefine checking.
                    func.exports = exports;
                    return func;
                } else {
                    return function () {
                        return exports.apply(global, arguments);
                    };
                }
            },

            requireDefined: function (id, relMap) {
                return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
            },

            requireSpecified: function (id, relMap) {
                id = makeModuleMap(id, relMap, false, true).id;
                return hasProp(defined, id) || hasProp(registry, id);
            },

            require: function (deps, callback, errback, relMap) {
                var moduleName, id, map, requireMod, args;
                if (typeof deps === 'string') {
                    if (isFunction(callback)) {
                        //Invalid call
                        return onError(makeError('requireargs', 'Invalid require call'), errback);
                    }

                    //Synchronous access to one module. If require.get is
                    //available (as in the Node adapter), prefer that.
                    //In this case deps is the moduleName and callback is
                    //the relMap
                    if (req.get) {
                        return req.get(context, deps, callback);
                    }

                    //Just return the module wanted. In this scenario, the
                    //second arg (if passed) is just the relMap.
                    moduleName = deps;
                    relMap = callback;

                    //Normalize module name, if it contains . or ..
                    map = makeModuleMap(moduleName, relMap, false, true);
                    id = map.id;

                    if (!hasProp(defined, id)) {
                        return onError(makeError('notloaded', 'Module name "' +
                                    id +
                                    '" has not been loaded yet for context: ' +
                                    contextName));
                    }
                    return defined[id];
                }

                //Callback require. Normalize args. if callback or errback is
                //not a function, it means it is a relMap. Test errback first.
                if (errback && !isFunction(errback)) {
                    relMap = errback;
                    errback = undefined;
                }
                if (callback && !isFunction(callback)) {
                    relMap = callback;
                    callback = undefined;
                }

                //Any defined modules in the global queue, intake them now.
                takeGlobalQueue();

                //Make sure any remaining defQueue items get properly processed.
                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                    } else {
                        //args are id, deps, factory. Should be normalized by the
                        //define() function.
                        callGetModule(args);
                    }
                }

                //Mark all the dependencies as needing to be loaded.
                requireMod = getModule(makeModuleMap(null, relMap));

                requireMod.init(deps, callback, errback, {
                    enabled: true
                });

                checkLoaded();

                return context.require;
            },

            undef: function (id) {
                var map = makeModuleMap(id, null, true),
                    mod = registry[id];

                delete defined[id];
                delete urlMap[id];
                delete urlFetched[map.url];
                delete undefEvents[id];

                if (mod) {
                    //Hold on to listeners in case the
                    //module will be attempted to be reloaded
                    //using a different config.
                    if (mod.events.defined) {
                        undefEvents[id] = mod.events;
                    }

                    removeWaiting(id);
                }
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. parent module is passed in for context,
             * used by the optimizer.
             */
            enable: function (depMap, parent) {
                var mod = registry[depMap.id];
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var shim = config.shim[moduleName] || {},
                shExports = shim.exports && shim.exports.exports,
                found, args, mod;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = registry[moduleName];

                if (!found &&
                    !defined[moduleName] &&
                    mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exports]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name + .extension into an URL path.
             * *Requires* the use of a module name. It does not support using
             * plain URLs like nameToUrl.
             */
            toUrl: function (moduleNamePlusExt, relModuleMap) {
                var index = moduleNamePlusExt.lastIndexOf('.'),
                    ext = null;

                if (index !== -1) {
                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                }

                return context.nameToUrl(moduleNamePlusExt, ext, relModuleMap);
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             */
            nameToUrl: function (moduleName, ext, relModuleMap) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;

                //Normalize module name if have a base relative module name to work from.
                moduleName = normalize(moduleName, relModuleMap && relModuleMap.id, true);

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = pkgs[parentModule];
                        parentPath = paths[parentModule];
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            //If module name is just the package name, then looking
                            //for the main module.
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/') + (ext || '.js');
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callack function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
                }
            }
        });
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var contextName = defContextName,
            context, config;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = contexts[contextName];
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require, using
    //default context if no context specified.
    addRequireMethods(req, contexts[defContextName]);

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = function (err) {
        throw err;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = config.xhtml ?
                   document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                   document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                //Check if node.attachEvent is artificially added by custom script or
                //natively supported by browser
                //read https://github.com/jrburke/requirejs/issues/187
                //if we can NOT find [native code] then it must NOT natively supported.
                //in IE8, node.attachEvent does not have toString()
                //Note the test for "[native code" with no closing brace, see:
                //https://github.com/jrburke/requirejs/issues/273
                !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEvenListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            //In a web worker, use importScripts. This is not a very
            //efficient use of importScripts, importScripts will block until
            //its script is downloaded and evaluated. However, if web workers
            //are in play, the expectation that a build has been done so that
            //only one script needs to be loaded anyway. This may need to be
            //reevaluated if other use cases become common.
            importScripts(url);

            //Account for anonymous modules
            context.completeLoad(moduleName);
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = dataMain.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    //Set final config.
                    cfg.baseUrl = subPath;
                    //Strip off any trailing .js since dataMain is now
                    //like a module name.
                    dataMain = mainScript.replace(jsSuffixRegExp, '');
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous functions
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = [];
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps.length && isFunction(callback)) {
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("js/lib/require.js", function(){});

var exports = (typeof(exports) === "undefined" ? this : exports); exports.parser = (function(){
  /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "binding": parse_binding,
        "boolean": parse_boolean,
        "float": parse_float,
        "fnc": parse_fnc,
        "index": parse_index,
        "number": parse_number,
        "parameter": parse_parameter,
        "parameterArray": parse_parameterArray,
        "path": parse_path,
        "pathElement": parse_pathElement,
        "staticBinding": parse_staticBinding,
        "string": parse_string,
        "text": parse_text,
        "twoWayBinding": parse_twoWayBinding,
        "var": parse_var,
        "varName": parse_varName
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "text";
      }
      
      var pos = 0;
      var reportMatchFailures = true;
      var rightmostMatchFailuresPos = 0;
      var rightmostMatchFailuresExpected = [];
      var cache = {};
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        
        if (charCode <= 0xFF) {
          var escapeChar = 'x';
          var length = 2;
        } else {
          var escapeChar = 'u';
          var length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function quote(s) {
        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
         * string literal except for the closing quote character, backslash,
         * carriage return, line separator, paragraph separator, and line feed.
         * Any character may appear in the form of an escape sequence.
         */
        return '"' + s
          .replace(/\\/g, '\\\\')            // backslash
          .replace(/"/g, '\\"')              // closing quote character
          .replace(/\r/g, '\\r')             // carriage return
          .replace(/\n/g, '\\n')             // line feed
          .replace(/[\x80-\uFFFF]/g, escape) // non-ASCII characters
          + '"';
      }
      
      function matchFailed(failure) {
        if (pos < rightmostMatchFailuresPos) {
          return;
        }
        
        if (pos > rightmostMatchFailuresPos) {
          rightmostMatchFailuresPos = pos;
          rightmostMatchFailuresExpected = [];
        }
        
        rightmostMatchFailuresExpected.push(failure);
      }
      
      function parse_varName() {
        var cacheKey = 'varName@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos1 = pos;
        var savedPos2 = pos;
        if (input.substr(pos).match(/^[a-zA-Z$_]/) !== null) {
          var result5 = input.charAt(pos);
          pos++;
        } else {
          var result5 = null;
          if (reportMatchFailures) {
            matchFailed("[a-zA-Z$_]");
          }
        }
        if (result5 !== null) {
          var result6 = [];
          if (input.substr(pos).match(/^[a-zA-Z0-9$_\- ]/) !== null) {
            var result7 = input.charAt(pos);
            pos++;
          } else {
            var result7 = null;
            if (reportMatchFailures) {
              matchFailed("[a-zA-Z0-9$_\\- ]");
            }
          }
          while (result7 !== null) {
            result6.push(result7);
            if (input.substr(pos).match(/^[a-zA-Z0-9$_\- ]/) !== null) {
              var result7 = input.charAt(pos);
              pos++;
            } else {
              var result7 = null;
              if (reportMatchFailures) {
                matchFailed("[a-zA-Z0-9$_\\- ]");
              }
            }
          }
          if (result6 !== null) {
            var result3 = [result5, result6];
          } else {
            var result3 = null;
            pos = savedPos2;
          }
        } else {
          var result3 = null;
          pos = savedPos2;
        }
        var result4 = result3 !== null
          ? (function(start, end) {return start ? start + end.join("") : false; })(result3[0], result3[1])
          : null;
        if (result4 !== null) {
          var result2 = result4;
        } else {
          var result2 = null;
          pos = savedPos1;
        }
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var savedPos0 = pos;
          var result1 = [];
          if (result1 !== null) {
            var result0 = result1;
          } else {
            var result0 = null;;
          };
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_string() {
        var cacheKey = 'string@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 1) === "'") {
          var result3 = "'";
          pos += 1;
        } else {
          var result3 = null;
          if (reportMatchFailures) {
            matchFailed("\"'\"");
          }
        }
        if (result3 !== null) {
          var result4 = [];
          var savedPos2 = pos;
          if (input.length > pos) {
            var result7 = input.charAt(pos);
            pos++;
          } else {
            var result7 = null;
            if (reportMatchFailures) {
              matchFailed('any character');
            }
          }
          var result8 = result7 !== null
            ? (function(char) { return char === "'" ? null : char; })(result7)
            : null;
          if (result8 !== null) {
            var result6 = result8;
          } else {
            var result6 = null;
            pos = savedPos2;
          }
          while (result6 !== null) {
            result4.push(result6);
            var savedPos2 = pos;
            if (input.length > pos) {
              var result7 = input.charAt(pos);
              pos++;
            } else {
              var result7 = null;
              if (reportMatchFailures) {
                matchFailed('any character');
              }
            }
            var result8 = result7 !== null
              ? (function(char) { return char === "'" ? null : char; })(result7)
              : null;
            if (result8 !== null) {
              var result6 = result8;
            } else {
              var result6 = null;
              pos = savedPos2;
            }
          }
          if (result4 !== null) {
            if (input.substr(pos, 1) === "'") {
              var result5 = "'";
              pos += 1;
            } else {
              var result5 = null;
              if (reportMatchFailures) {
                matchFailed("\"'\"");
              }
            }
            if (result5 !== null) {
              var result1 = [result3, result4, result5];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(s) { return s.join(""); })(result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_number() {
        var cacheKey = 'number@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 1) === "-") {
          var result6 = "-";
          pos += 1;
        } else {
          var result6 = null;
          if (reportMatchFailures) {
            matchFailed("\"-\"");
          }
        }
        var result3 = result6 !== null ? result6 : '';
        if (result3 !== null) {
          if (input.substr(pos).match(/^[0-9]/) !== null) {
            var result5 = input.charAt(pos);
            pos++;
          } else {
            var result5 = null;
            if (reportMatchFailures) {
              matchFailed("[0-9]");
            }
          }
          if (result5 !== null) {
            var result4 = [];
            while (result5 !== null) {
              result4.push(result5);
              if (input.substr(pos).match(/^[0-9]/) !== null) {
                var result5 = input.charAt(pos);
                pos++;
              } else {
                var result5 = null;
                if (reportMatchFailures) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            var result4 = null;
          }
          if (result4 !== null) {
            var result1 = [result3, result4];
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(n, digits) { return parseInt(digits.join(""), 10) * (n ? -1 : 1); })(result1[0], result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_float() {
        var cacheKey = 'float@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        var result3 = parse_number();
        if (result3 !== null) {
          if (input.substr(pos, 1) === ".") {
            var result4 = ".";
            pos += 1;
          } else {
            var result4 = null;
            if (reportMatchFailures) {
              matchFailed("\".\"");
            }
          }
          if (result4 !== null) {
            if (input.substr(pos).match(/^[0-9]/) !== null) {
              var result6 = input.charAt(pos);
              pos++;
            } else {
              var result6 = null;
              if (reportMatchFailures) {
                matchFailed("[0-9]");
              }
            }
            if (result6 !== null) {
              var result5 = [];
              while (result6 !== null) {
                result5.push(result6);
                if (input.substr(pos).match(/^[0-9]/) !== null) {
                  var result6 = input.charAt(pos);
                  pos++;
                } else {
                  var result6 = null;
                  if (reportMatchFailures) {
                    matchFailed("[0-9]");
                  }
                }
              }
            } else {
              var result5 = null;
            }
            if (result5 !== null) {
              var result1 = [result3, result4, result5];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(n, d2) { return parseFloat(n+"."+d2.join(""), 10) })(result1[0], result1[2])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_boolean() {
        var cacheKey = 'boolean@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos1 = pos;
        if (input.substr(pos, 4) === "true") {
          var result5 = "true";
          pos += 4;
        } else {
          var result5 = null;
          if (reportMatchFailures) {
            matchFailed("\"true\"");
          }
        }
        var result6 = result5 !== null
          ? (function() { return true; })()
          : null;
        if (result6 !== null) {
          var result4 = result6;
        } else {
          var result4 = null;
          pos = savedPos1;
        }
        if (result4 !== null) {
          var result0 = result4;
        } else {
          var savedPos0 = pos;
          if (input.substr(pos, 5) === "false") {
            var result2 = "false";
            pos += 5;
          } else {
            var result2 = null;
            if (reportMatchFailures) {
              matchFailed("\"false\"");
            }
          }
          var result3 = result2 !== null
            ? (function() { return false; })()
            : null;
          if (result3 !== null) {
            var result1 = result3;
          } else {
            var result1 = null;
            pos = savedPos0;
          }
          if (result1 !== null) {
            var result0 = result1;
          } else {
            var result0 = null;;
          };
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_index() {
        var cacheKey = 'index@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 1) === "[") {
          var result3 = "[";
          pos += 1;
        } else {
          var result3 = null;
          if (reportMatchFailures) {
            matchFailed("\"[\"");
          }
        }
        if (result3 !== null) {
          var result4 = parse_number();
          if (result4 !== null) {
            if (input.substr(pos, 1) === "]") {
              var result5 = "]";
              pos += 1;
            } else {
              var result5 = null;
              if (reportMatchFailures) {
                matchFailed("\"]\"");
              }
            }
            if (result5 !== null) {
              var result1 = [result3, result4, result5];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(n) { return n; })(result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_parameter() {
        var cacheKey = 'parameter@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var result6 = parse_string();
        if (result6 !== null) {
          var result0 = result6;
        } else {
          var result5 = parse_boolean();
          if (result5 !== null) {
            var result0 = result5;
          } else {
            var result4 = parse_float();
            if (result4 !== null) {
              var result0 = result4;
            } else {
              var result3 = parse_number();
              if (result3 !== null) {
                var result0 = result3;
              } else {
                var result2 = parse_staticBinding();
                if (result2 !== null) {
                  var result0 = result2;
                } else {
                  var result1 = parse_binding();
                  if (result1 !== null) {
                    var result0 = result1;
                  } else {
                    var result0 = null;;
                  };
                };
              };
            };
          };
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_parameterArray() {
        var cacheKey = 'parameterArray@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        var result10 = parse_parameter();
        var result3 = result10 !== null ? result10 : '';
        if (result3 !== null) {
          var result4 = [];
          var savedPos2 = pos;
          var savedPos3 = pos;
          if (input.substr(pos, 1) === ",") {
            var result8 = ",";
            pos += 1;
          } else {
            var result8 = null;
            if (reportMatchFailures) {
              matchFailed("\",\"");
            }
          }
          if (result8 !== null) {
            var result9 = parse_parameter();
            if (result9 !== null) {
              var result6 = [result8, result9];
            } else {
              var result6 = null;
              pos = savedPos3;
            }
          } else {
            var result6 = null;
            pos = savedPos3;
          }
          var result7 = result6 !== null
            ? (function(r) {return r;})(result6[1])
            : null;
          if (result7 !== null) {
            var result5 = result7;
          } else {
            var result5 = null;
            pos = savedPos2;
          }
          while (result5 !== null) {
            result4.push(result5);
            var savedPos2 = pos;
            var savedPos3 = pos;
            if (input.substr(pos, 1) === ",") {
              var result8 = ",";
              pos += 1;
            } else {
              var result8 = null;
              if (reportMatchFailures) {
                matchFailed("\",\"");
              }
            }
            if (result8 !== null) {
              var result9 = parse_parameter();
              if (result9 !== null) {
                var result6 = [result8, result9];
              } else {
                var result6 = null;
                pos = savedPos3;
              }
            } else {
              var result6 = null;
              pos = savedPos3;
            }
            var result7 = result6 !== null
              ? (function(r) {return r;})(result6[1])
              : null;
            if (result7 !== null) {
              var result5 = result7;
            } else {
              var result5 = null;
              pos = savedPos2;
            }
          }
          if (result4 !== null) {
            var result1 = [result3, result4];
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(s, rp) {return s ? [s].concat(rp) : []; })(result1[0], result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_var() {
        var cacheKey = 'var@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        var result3 = parse_varName();
        if (result3 !== null) {
          var result5 = parse_index();
          var result4 = result5 !== null ? result5 : '';
          if (result4 !== null) {
            var result1 = [result3, result4];
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(n, ind) { return {name: n, type: 'var', index: ind}; })(result1[0], result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_fnc() {
        var cacheKey = 'fnc@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        var result3 = parse_varName();
        if (result3 !== null) {
          if (input.substr(pos, 1) === "(") {
            var result4 = "(";
            pos += 1;
          } else {
            var result4 = null;
            if (reportMatchFailures) {
              matchFailed("\"(\"");
            }
          }
          if (result4 !== null) {
            var result9 = parse_parameterArray();
            var result5 = result9 !== null ? result9 : '';
            if (result5 !== null) {
              if (input.substr(pos, 1) === ")") {
                var result6 = ")";
                pos += 1;
              } else {
                var result6 = null;
                if (reportMatchFailures) {
                  matchFailed("\")\"");
                }
              }
              if (result6 !== null) {
                var result8 = parse_index();
                var result7 = result8 !== null ? result8 : '';
                if (result7 !== null) {
                  var result1 = [result3, result4, result5, result6, result7];
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(n, pa, ind) {return {name: n, type: 'fnc', parameter: pa, index: ind  }; })(result1[0], result1[2], result1[4])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_pathElement() {
        var cacheKey = 'pathElement@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var result4 = parse_index();
        var result5 = result4 !== null
          ? (function(ind) { return {type: 'index', index: ind }; })(result4)
          : null;
        if (result5 !== null) {
          var result3 = result5;
        } else {
          var result3 = null;
          pos = savedPos0;
        }
        if (result3 !== null) {
          var result0 = result3;
        } else {
          var result2 = parse_fnc();
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result1 = parse_var();
            if (result1 !== null) {
              var result0 = result1;
            } else {
              var result0 = null;;
            };
          };
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_path() {
        var cacheKey = 'path@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        var result3 = parse_pathElement();
        if (result3 !== null) {
          var result4 = [];
          var savedPos2 = pos;
          var savedPos3 = pos;
          if (input.substr(pos, 1) === ".") {
            var result8 = ".";
            pos += 1;
          } else {
            var result8 = null;
            if (reportMatchFailures) {
              matchFailed("\".\"");
            }
          }
          if (result8 !== null) {
            var result9 = parse_pathElement();
            if (result9 !== null) {
              var result6 = [result8, result9];
            } else {
              var result6 = null;
              pos = savedPos3;
            }
          } else {
            var result6 = null;
            pos = savedPos3;
          }
          var result7 = result6 !== null
            ? (function(r) {return r;})(result6[1])
            : null;
          if (result7 !== null) {
            var result5 = result7;
          } else {
            var result5 = null;
            pos = savedPos2;
          }
          while (result5 !== null) {
            result4.push(result5);
            var savedPos2 = pos;
            var savedPos3 = pos;
            if (input.substr(pos, 1) === ".") {
              var result8 = ".";
              pos += 1;
            } else {
              var result8 = null;
              if (reportMatchFailures) {
                matchFailed("\".\"");
              }
            }
            if (result8 !== null) {
              var result9 = parse_pathElement();
              if (result9 !== null) {
                var result6 = [result8, result9];
              } else {
                var result6 = null;
                pos = savedPos3;
              }
            } else {
              var result6 = null;
              pos = savedPos3;
            }
            var result7 = result6 !== null
              ? (function(r) {return r;})(result6[1])
              : null;
            if (result7 !== null) {
              var result5 = result7;
            } else {
              var result5 = null;
              pos = savedPos2;
            }
          }
          if (result4 !== null) {
            var result1 = [result3, result4];
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(s, rp) {return [s].concat(rp);})(result1[0], result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_binding() {
        var cacheKey = 'binding@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 1) === "{") {
          var result3 = "{";
          pos += 1;
        } else {
          var result3 = null;
          if (reportMatchFailures) {
            matchFailed("\"{\"");
          }
        }
        if (result3 !== null) {
          var result4 = parse_path();
          if (result4 !== null) {
            if (input.substr(pos, 1) === "}") {
              var result5 = "}";
              pos += 1;
            } else {
              var result5 = null;
              if (reportMatchFailures) {
                matchFailed("\"}\"");
              }
            }
            if (result5 !== null) {
              var result1 = [result3, result4, result5];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(path) { return path ? {path: path,type:'normal'} : false; })(result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_twoWayBinding() {
        var cacheKey = 'twoWayBinding@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 2) === "{{") {
          var result3 = "{{";
          pos += 2;
        } else {
          var result3 = null;
          if (reportMatchFailures) {
            matchFailed("\"{{\"");
          }
        }
        if (result3 !== null) {
          var result4 = parse_path();
          if (result4 !== null) {
            var savedPos4 = pos;
            var savedPos5 = pos;
            if (input.substr(pos, 1) === "|") {
              var result16 = "|";
              pos += 1;
            } else {
              var result16 = null;
              if (reportMatchFailures) {
                matchFailed("\"|\"");
              }
            }
            if (result16 !== null) {
              var result17 = parse_path();
              if (result17 !== null) {
                var result14 = [result16, result17];
              } else {
                var result14 = null;
                pos = savedPos5;
              }
            } else {
              var result14 = null;
              pos = savedPos5;
            }
            var result15 = result14 !== null
              ? (function(p) {return p;})(result14[1])
              : null;
            if (result15 !== null) {
              var result13 = result15;
            } else {
              var result13 = null;
              pos = savedPos4;
            }
            var result5 = result13 !== null ? result13 : '';
            if (result5 !== null) {
              var savedPos2 = pos;
              var savedPos3 = pos;
              if (input.substr(pos, 1) === "|") {
                var result11 = "|";
                pos += 1;
              } else {
                var result11 = null;
                if (reportMatchFailures) {
                  matchFailed("\"|\"");
                }
              }
              if (result11 !== null) {
                var result12 = parse_path();
                if (result12 !== null) {
                  var result9 = [result11, result12];
                } else {
                  var result9 = null;
                  pos = savedPos3;
                }
              } else {
                var result9 = null;
                pos = savedPos3;
              }
              var result10 = result9 !== null
                ? (function(p) {return p;})(result9[1])
                : null;
              if (result10 !== null) {
                var result8 = result10;
              } else {
                var result8 = null;
                pos = savedPos2;
              }
              var result6 = result8 !== null ? result8 : '';
              if (result6 !== null) {
                if (input.substr(pos, 2) === "}}") {
                  var result7 = "}}";
                  pos += 2;
                } else {
                  var result7 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"}}\"");
                  }
                }
                if (result7 !== null) {
                  var result1 = [result3, result4, result5, result6, result7];
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(path, a, b) { return path ? {path: path,type:'twoWay', transformBack: a || false, transform: b || false} : false; })(result1[1], result1[2], result1[3])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_staticBinding() {
        var cacheKey = 'staticBinding@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var savedPos1 = pos;
        if (input.substr(pos, 1) === "$") {
          var result3 = "$";
          pos += 1;
        } else {
          var result3 = null;
          if (reportMatchFailures) {
            matchFailed("\"$\"");
          }
        }
        if (result3 !== null) {
          var result4 = parse_binding();
          if (result4 !== null) {
            var result1 = [result3, result4];
          } else {
            var result1 = null;
            pos = savedPos1;
          }
        } else {
          var result1 = null;
          pos = savedPos1;
        }
        var result2 = result1 !== null
          ? (function(b) { b.type = 'static'; return b; })(result1[1])
          : null;
        if (result2 !== null) {
          var result0 = result2;
        } else {
          var result0 = null;
          pos = savedPos0;
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_text() {
        var cacheKey = 'text@' + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        
        var savedPos0 = pos;
        var result7 = parse_twoWayBinding();
        var result8 = result7 !== null
          ? (function(t) { return [t]; })(result7)
          : null;
        if (result8 !== null) {
          var result6 = result8;
        } else {
          var result6 = null;
          pos = savedPos0;
        }
        if (result6 !== null) {
          var result0 = result6;
        } else {
          var result1 = [];
          var result5 = parse_staticBinding();
          if (result5 !== null) {
            var result2 = result5;
          } else {
            var result4 = parse_binding();
            if (result4 !== null) {
              var result2 = result4;
            } else {
              if (input.length > pos) {
                var result3 = input.charAt(pos);
                pos++;
              } else {
                var result3 = null;
                if (reportMatchFailures) {
                  matchFailed('any character');
                }
              }
              if (result3 !== null) {
                var result2 = result3;
              } else {
                var result2 = null;;
              };
            };
          }
          while (result2 !== null) {
            result1.push(result2);
            var result5 = parse_staticBinding();
            if (result5 !== null) {
              var result2 = result5;
            } else {
              var result4 = parse_binding();
              if (result4 !== null) {
                var result2 = result4;
              } else {
                if (input.length > pos) {
                  var result3 = input.charAt(pos);
                  pos++;
                } else {
                  var result3 = null;
                  if (reportMatchFailures) {
                    matchFailed('any character');
                  }
                }
                if (result3 !== null) {
                  var result2 = result3;
                } else {
                  var result2 = null;;
                };
              };
            }
          }
          if (result1 !== null) {
            var result0 = result1;
          } else {
            var result0 = null;;
          };
        }
        
        
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function buildErrorMessage() {
        function buildExpected(failuresExpected) {
          failuresExpected.sort();
          
          var lastFailure = null;
          var failuresExpectedUnique = [];
          for (var i = 0; i < failuresExpected.length; i++) {
            if (failuresExpected[i] !== lastFailure) {
              failuresExpectedUnique.push(failuresExpected[i]);
              lastFailure = failuresExpected[i];
            }
          }
          
          switch (failuresExpectedUnique.length) {
            case 0:
              return 'end of input';
            case 1:
              return failuresExpectedUnique[0];
            default:
              return failuresExpectedUnique.slice(0, failuresExpectedUnique.length - 1).join(', ')
                + ' or '
                + failuresExpectedUnique[failuresExpectedUnique.length - 1];
          }
        }
        
        var expected = buildExpected(rightmostMatchFailuresExpected);
        var actualPos = Math.max(pos, rightmostMatchFailuresPos);
        var actual = actualPos < input.length
          ? quote(input.charAt(actualPos))
          : 'end of input';
        
        return 'Expected ' + expected + ' but ' + actual + ' found.';
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i <  rightmostMatchFailuresPos; i++) {
          var ch = input.charAt(i);
          if (ch === '\n') {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === '\r' | ch === '\u2028' || ch === '\u2029') {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostMatchFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostMatchFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostMatchFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var errorPosition = computeErrorPosition();
        throw new this.SyntaxError(
          buildErrorMessage(),
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(message, line, column) {
    this.name = 'SyntaxError';
    this.message = message;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
define('js/lib/parser', function () { return exports.parser; });
define("js/lib/parser", function(){});

var inherit;

(function (global, exports) {

    /**
     *
     * @param {String} [constructorName] The name of the constructor
     * @param {Object} classDefinition The definition for the prototype methods
     * @param {Object} [staticDefinition] The definition for the prototype methods
     * @param {Function} [baseClass] The prototype to inherit from
     *
     * @return {Function} returns a constructor function describing the class
     */
    inherit = function (constructorName, classDefinition, staticDefinition, baseClass) {

        var args = Array.prototype.slice.call(arguments);

        if (args[0] instanceof Object) {
            args.unshift(null);
        }

        if (args[2] instanceof Function) {
            args.splice(2, 0, null);
        }

        constructorName = args[0];
        classDefinition = args[1] || {};
        staticDefinition = args[2] || {};
        baseClass = args[3] || Object;

        var newClass = function () {
            if (this.ctor) {
                return this.ctor.apply(this, arguments);
            }
        };

        if (baseClass.constructor instanceof Function) {

            function Inheritance() {
            }

            Inheritance.prototype = baseClass.prototype;

            newClass.prototype = new Inheritance();
            newClass.prototype.constructor = classDefinition;

            if (classDefinition && constructorName) {
                newClass.prototype.constructor.name = constructorName;
            }

            newClass.prototype.base = baseClass.prototype;

        } else {
            newClass.prototype = baseClass;
            newClass.prototype.constructor = classDefinition;
            newClass.prototype.base = baseClass;
        }

        for (var publicMethod in classDefinition) {
            if (classDefinition.hasOwnProperty(publicMethod)) {
                var baseFunction = newClass.prototype[publicMethod];
                newClass.prototype[publicMethod] = classDefinition[publicMethod];

                if (baseFunction instanceof Function) {
                    newClass.prototype[publicMethod].baseImplementation = baseFunction;
                }
            }
        }

        for (var staticMethod in staticDefinition) {
            if (staticDefinition.hasOwnProperty(staticMethod)) {
                newClass[staticMethod] = staticDefinition[staticMethod];
            }
        }

        newClass.prototype.callBase = inherit.callBase;

        return newClass;

    };

    inherit.callBase = function () {
        // get arguments
        var args = Array.prototype.slice.call(arguments);

        if (args.length == 0) {
            // use arguments from call
            args = Array.prototype.slice.call(arguments.callee.caller.arguments);
        }

        return arguments.callee.caller.baseImplementation.apply(this, args);
    };



    /***
     *
     * @param {String} [constructorName]
     * @param {Object} classDefinition The definition for the prototype methods
     * @param {Object} [staticDefinition]
     * @return {Function} returns a constructor function describing the class
     */
    Function.prototype.inherit = function (constructorName, classDefinition, staticDefinition) {

        var args = Array.prototype.slice.call(arguments);

        if (args[0] instanceof Object) {
            args.unshift(null);
        }

        return inherit(args[0], args[1], args[2], this);
    };

    Function.prototype.callBase = function () {
        var args = Array.prototype.slice.call(arguments);
        var that = args.shift();

        if (that && that.base) {
            var caller = arguments.callee.caller;

            if (this == caller) {
                return this.baseImplementation.apply(that, args);
            } else {
                return this.apply(that, args);
            }
        } else {
            throw "base not definied";
        }
    };

    Function.prototype.classof = function(factory) {
        if (!factory) {
            return false;
        }

        if (!(factory instanceof Function)) {
            throw new Error("factory must be a function");
        }

        return (factory === this || this.prototype instanceof factory);
    };

    /**
     * @property {Function} base class
     */
    inherit.Base = inherit({
        ctor: function () {
        }
    });

    exports.inherit = inherit;

})(this, typeof exports === "undefined" ? this : exports);

define('inherit', function () { return inherit; });
define("inherit", function(){});

define('js/core/Base',["inherit"], function(inherit){

    var Base = inherit.Base.inherit("js.core.Base",{
        /** @lends Base **/
        ctor: function () {
        },

        runsInBrowser: function () {
            return typeof window !== "undefined";
        },

        /***
         *
         * @param {String|Array} message
         * @param {String} [level="info"]
         */
        log: function(message, level) {
            level = level || Base.LOGLEVEL.INFO;

            if (message instanceof Error) {
                message = message.toString();
            }

            if (Base.logger.length) {
                for (var i = 0; i < Base.logger.length; i++) {
                    Base.logger[i].log(message, level);
                }
            } else if (typeof console !== "undefined") {
                (console[level] || console.log).call(console, message);
            }
        }
    });

    Base.logger = [];
    Base.LOGLEVEL = {
        DEBUG: 'debug',
        INFO: 'info',
        WARN: 'warn',
        ERROR: 'error'
    };

    return Base;
});
define('js/core/EventDispatcher',["js/core/Base"],
    function (Base) {

        /***
         * @param {arguments} eventTypes
         * */
        Function.prototype.on = function () {

            var events = Array.prototype.slice.call(arguments, 0);
            this._events = this._events || [];
            for (var i = 0; i < events.length; i++) {
                var event = events[i];
                this._events.push(event);
            }

            return this;
        };


        /***
         * @param {arguments} changeEvents results in change:eventName
         * */
        Function.prototype.onChange = function () {
            var events = Array.prototype.slice.call(arguments, 0);
            this._events = this._events || [];
            this._attributes = this._attributes || [];
            for (var i = 0; i < events.length; i++) {
                var event = events[i];
                this._attributes.push(event);
                event = "change:" + event;
                this._events.push(event);

            }
            return this;
        };

        Function.prototype.bus = function() {

            var events = Array.prototype.slice.call(arguments);
            this._busEvents = this._busEvents || [];
            for (var i = 0; i < events.length; i++) {
                this._busEvents.push(events[i]);
            }

            return this;
        };

        var undefinedValue;

        /** @class */
        var EventDispatcher = Base.inherit("js.core.EventDispatcher",
            /** @lends EventDispatcher.prototype */
            {

                /**
                 * @class Allows binding and triggering of custom events
                 * @constructs
                 */
                ctor: function () {
                    this.callBase();
                    this._eventHandlers = {};
                },
                /**
                 * Binds a callback and a scope to a given eventType
                 * @public
                 * @param {String} eventType The name of the event
                 * @param {Function} callback The callback function - signature callback({@link EventDispatcher.Event},[caller])
                 * @param {Object} [scope]  This sets the scope for the callback function
                 */
                bind: function (eventType, callback, scope) {
                    if (callback) {
                        scope = scope || this;
                        // get the list for the event
                        var list = this._eventHandlers[eventType] || (this._eventHandlers[eventType] = []);
                        // and push the callback function
                        list.push(new EventDispatcher.EventHandler(callback, scope));
                    } else {
                        console.warn('no eventHandler for "' + eventType + '"');
                    }

                    return this;
                },
                /**
                 * Triggers an event
                 * @public
                 * @param {String} eventType
                 * @param {EventDispatcher.Event|Object} event If you use an Object the object is wrapped in an Event
                 * @param target
                 */
                trigger: function (eventType, event, target) {

                    if (this._eventHandlers[eventType]) {
                        if (!(event instanceof EventDispatcher.Event)) {
                            event = new EventDispatcher.Event(event);
                        }

                        if (!target) {
                            target = arguments.callee.caller;
                        }
                        event.target = target;
                        event.type = eventType;

                        var list = this._eventHandlers[eventType];
                        for (var i = 0; i < list.length; i++) {
                            if (list[i]) {
                                var result = list[i].trigger(event, target);

                                if (result !== undefinedValue) {
                                    ret = result;
                                    if (result === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }

                                if (event.isImmediatePropagationStopped) {
                                    break;
                                }
                            }
                        }
                    }

                    return event;
                },
                /***
                 * Unbinds callbacks for events
                 * @public
                 * @param {String} eventType
                 * @param {Function} callback
                 */
                unbind: function (eventType, callback, scope) {
                    if (!eventType) {
                        // remove all events
                        this._eventHandlers = {};
                    } else if (!callback) {
                        // remove all callbacks for these event
                        this._eventHandlers[eventType] = [];
                    } else if (this._eventHandlers[eventType]) {
                        var list = this._eventHandlers[eventType];
                        for (var i = list.length - 1; i >= 0; i--) {
                            if (list[i].$callback == callback && (!scope || scope === list[i].scope)) {
                                list.splice(i, 1);  // delete callback
                            }
                        }
                    }
                },
                destroy: function(){
                    // remove all events
                    this._eventHandlers = {};
                }
            });

        EventDispatcher.Event = Base.inherit(
            /** @lends EventDispatcher.Event.prototype */
            {
                /**
                 * Description of constructor.
                 * @class Description of class.
                 * @constructs
                 * @params {Object} attributes Hash of attributes
                 */
                ctor: function (attributes, target) {
                    this.$ = attributes;

                    this.target = target;
                    this.isDefaultPrevented = false;
                    this.isPropagationStopped = false;
                    this.isImmediatePropagationStopped = false;

                },
                /**
                 * Prevent default triggering
                 * @public
                 */
                preventDefault: function () {
                    this.isDefaultPrevented = true;

                    var e = this.$.orginalEvent;

                    if (e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        } else {
                            e.returnValue = false;  // IE
                        }
                    }
                },
                /**
                 * Call this to stop propagation
                 * @public
                 */
                stopPropagation: function () {
                    this.isPropagationStopped = true;
                },
                /**
                 * @public
                 */
                stopImmediatePropagation: function () {
                    this.isImmediatePropagationStopped = true;
                    this.stopPropagation();
                }
            });


        EventDispatcher.EventHandler = Base.inherit(
            /** @lends EventDispatcher.EventHandler.prototype */
            {
                /**
                 * Simple EventHandler
                 * @class
                 * @constructs
                 * @params {Function} callback The callback function
                 * @params {Object} scope The callback scope
                 */
                ctor: function (callback, scope) {
                    this.scope = scope;
                    this.$callback = callback;
                },
                /**
                 *
                 * @param {EventDispatcher.Event} event
                 * @param {Object} caller
                 */
                trigger: function (event, caller) {
                    this.$callback.call(this.scope, event, caller);
                    return !event.isPropagationStopped;
                }
            });

        return EventDispatcher;
    }
);
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
define('underscore', function () { return _; });
define("underscore", function(){});

define('js/core/Binding',["js/core/EventDispatcher", "js/lib/parser", "underscore"], function (EventDispatcher, Parser, _) {

    /**
     * Returns false if path includes function
     * @param path
     */
    var pathToString = function (path) {
        var str = [];
        for (var i = 0; i < path.length; i++) {
            var el = path[i];
            if (el.type == TYPE_VAR) {
                str.push(el.name);
            } else {
                return false;
            }
        }
        return str.join(".");
    };
    var Bindable;
    var Binding = EventDispatcher.inherit("js.core.Binding",
        /** @lends Binding */
        {
            defaults: {
                event: 'change',
                path: null,
                twoWay: false
            },

            ctor: function (attributes) {
                if(!Bindable){
                    try {
                        Bindable = requirejs('js/core/Bindable');
                    } catch(e) {
                        Bindable = null;
                    }
                }
                this.callBase();

                this.$ = attributes;
                _.defaults(this.$,this.defaults);

                this.initialize();
            },

            transform: function (val) {
                return val;
            },

            transformBack: function (val) {
                return val;
            },

            initialize: function () {
                this._checkAttributes();
                this.$parameters = [];
                this.$events = [];
                this.$subBinding = null;

                if (!this.$.rootScope) {
                    this.$.rootScope = this;
                }
                var scope = this.$.scope;
                if(_.isString(this.$.path)){
                    this.$.path = Parser.parse(this.$.path,'path');
                }
                // split up first key
                this.$.key = this.$.path[0];
                var self = this;

                if (this.$.key.type == TYPE_FNC) {
                    var fncName = this.$.key.name;
                    this.$parameters = this.$.key.parameter;

                    if (_.isFunction(scope[fncName])) {
                        var fnc = scope[fncName];
                        var events = [];
                        if (fnc._attributes && fnc._attributes.length > 0) {
                            this.$.scope.bind("change", this._changeCallback, this);
                            this.$events.push({eventType: "change", callback: this._changeCallback});
                        } else {
                            if (fnc._events) {
                                events = fnc._events;
                            } else {
                                events = [];
                            }

                            var event, path;
                            for (var i = 0; i < events.length; i++) {
                                event = events[i];
                                scope.bind(event, this._callback, this);
                                this.$events.push({eventType: event, callback: this._callback});
                            }
                        }

                        var cb = function () {
                            self.trigger();
                        };

                        var para;
                        for (var j = 0; j < this.$parameters.length; j++) {
                            para = this.$parameters[j];
                            if (_.isObject(para)) {
                                this.$parameters[j] = this.$.bindingCreator.create(para, this.$.target, cb);
                            }

                        }
                        this.$.fnc = fnc;
                        this.$.fnc.trigger = function () {
                            self.trigger();
                        };
                    }

                } else {
                    this.$.event = "change:" + this.$.key.name;
                    this.$events.push({eventType: this.$.event, callback: this._callback});
                    // on change of this key
                    scope.bind(this.$.event, this._callback, this);
                }

                if (this.$.twoWay === true && this.$.path.length === 1) {
                    this.$.targetEvent = 'change:' + this.$.targetKey;

                    this.$.target.bind(this.$.targetEvent, this._revCallback, this);
                }

                this._createSubBinding();
                scope.bind('destroy', function () {
                    self.destroy();
                });


                if (this.$.path.length === 1) {
                    this.trigger();
                }
            },
            _checkAttributes: function () {
                // check infrastructur
                if (!this.$.path) {
                    throw "No path defined!";
                }

                if (!this.$.scope) {
                    throw "No scope defined!"
                }

                if (this.$.twoWay) {
                    if (!this.$.target) {
                        throw "TwoWay binding, but no target defined!";
                    }
                    if (!this.$.target instanceof Bindable) {
                        throw "Target is not a Bindable!";
                    }

                    if (!this.$.targetKey) {
                        throw "TwoWay binding, but no target key defined!";
                    }

                }

                if(!this.$.bindingCreator){
                    this.$.bindingCreator = this;
                }

                if(this.$.transform){
                    this.transform = this.$.transform;
                }

                if (this.$.transformBack) {
                    this.transformBack = this.$.transformBack;
                }


            },
            _createSubBinding: function () {
                if (this.$.path.length > 1) {
                    var nScope;
                    if (this.$.fnc) {
                        nScope = this.getValue();
                    } else {
                        nScope = this.$.scope.$[this.$.key.name];
                    }
                    // if keys are left and has value && is bindable
                    // get value for first child
                    if (nScope) {
                        if(nScope instanceof Bindable){
                            // init new binding, which triggers this binding
                            this.$subBinding = new Binding({scope: nScope, path: this.$.path.slice(1), target: this.$.target, targetKey: this.$.targetKey, rootScope: this.$.rootScope, callback: this.$.callback, context: this.$.context, twoWay: this.$.twoWay, transform: this.$.transform, transformBack: this.$.transformBack, bindingCreator: this.$.bindingCreator});
                        } else {
                            // TODO: find next bindable var
                        }


                    }
                }
            },
            _revCallback: function (e) {
                if (this.$.fnc) {
                    var params = this._getFncParameters();
                    params.unshift(e.$);
                    this.$.fnc.apply(this.$.scope, params);
                } else {
                    this.$.scope.set(pathToString(this.$.path), this.transformBack(e.$));
                }
            },
            _changeCallback: function (event) {
                for (var i = 0; i < this.$.fnc._attributes.length; i++) {
                    if (!_.isUndefined(event.$[this.$.fnc._attributes[i]])) {
                        this.trigger();
                        return;
                    }
                }
            },
            _callback: function () {
                // remove subBindings!
                if (this.$subBinding) {
                    this.$subBinding.destroy();
                    this.$subBinding = null;
                }

                // try to create subBinding
                this._createSubBinding();

                this.trigger();
            },
            destroy: function () {
                var e;
                for (var j = 0; j < this.$events.length; j++) {
                    e = this.$events[j];
                    this.$.scope.unbind(e.eventType, e.callback);
                }

                if (this.$.twoWay === true) {
                    this.$.target.unbind(this.$.targetEvent, this._revCallback);
                }
                if (this.$subBinding) {
                    this.$subBinding.destroy();

                    delete this.$subBinding;
                }

                // destroy parameter bindings
                for (var i = 0; i < this.$parameters.length; i++) {
                    var par = this.$parameters[i];
                    if (par instanceof Binding) {
                        par.destroy();
                    }
                }
            },
            _getFncParameters: function () {
                var parameters = [];
                for (var i = 0; i < this.$parameters.length; i++) {
                    var para = this.$parameters[i];
                    if (para instanceof Binding) {
                        para = para.getValue();
                    }
                    parameters.push(para);
                }
                return parameters;
            },
            getValue: function () {
                if (this.$subBinding) {
                    return this.$subBinding.getValue();
                } else {
                    if (this.$.fnc) {
                        return this.$.fnc.apply(this.$.scope, this._getFncParameters());
                    } else if (this.$.path.length == 1) {
                        return this.$.scope.get(this.$.key.name);
                    } else {
                        return null;
                    }
                }
            },
            getContextValue: function () {
                if (this.$.context && this.$.context.length > 1) {
                    return Binding.contextToString(this.$.context);
                } else {
                    return this.getValue();
                }
            },
            // trigger
            trigger: function () {
                // get value
                var val = this.getContextValue();
                if (this.$.targetKey) {
                    this.$.target.set(this.$.targetKey, this.transform(val));
                } else if (this.$.callback) {
                    this.$.callback.call(this.$.target, this.transform(val));
                }

            },
            toString: function () {
                return this.getValue();
            },
            create: function(bindingDef, target, callback){
                var options = {scope: this.$.scope, target: target, callback: callback, path: bindingDef.path, twoWay : bindingDef.type === TYPE_TWOWAY, bindingCreator: this.$.bindingCreator};

                var fncEl;
                var fncScope;
                if(bindingDef.transform) {
                    fncEl = bindingDef.transform.pop();
                    fncScope = this.get(bindingDef.transform);
                    if(fncScope){
                        options.transform = fncScope[fncEl.name];
                    }
                }
                if(bindingDef.transformBack){
                    fncEl = bindingDef.transformBack.pop();
                    fncScope = this.get(bindingDef.transform);
                    if (fncScope) {
                        options.transformBack = fncScope[fncEl.name];
                    }
                }
                return new Binding(options);
            }
        });

    var TYPE_FNC = Binding.TYPE_FNC = "fnc";
    var TYPE_VAR = Binding.TYPE_VAR = "var";
    var TYPE_STATIC = Binding.TYPE_STATIC ="static";
    var TYPE_TWOWAY = Binding.TYPE_TWOWAY ="twoWay";

    Binding.contextToString = function (context) {
        var str = "", el;
        for (var i = 0; i < context.length; i++) {
            el = context[i];
            if (el instanceof Binding) {
                el = el.getValue();
            }
            if (el !== null && typeof(el) !== "undefined") {
                str += el;
            }
        }
        return str;
    };

    return Binding;
});
define('js/core/BindingCreator',['js/core/EventDispatcher','js/lib/parser','js/core/Binding', 'underscore'], function(EventDispatcher,Parser, Binding, _){

    function findTransformFunction(path, scope) {
        var pathElement = path[0];
        if (pathElement.type == Binding.TYPE_FNC) {
            scope = scope.getScopeForFncName(pathElement.name);
        } else {
            scope = scope.getScopeForKey(pathElement.name);
        }

        var nScope = scope;
        while (nScope && path.length > 0) {
            pathElement = path.shift();
            if (pathElement.type == Binding.TYPE_FNC) {
                return nScope[pathElement.name];
            } else if (pathElement.type == Binding.TYPE_VAR) {
                nScope = nScope.get(pathElement.name);
            }
        }

        return false;
    }

    return EventDispatcher.inherit('js.core.BindingCreator',{

        create: function(bindingDef, targetScope, attrKey, context){
            var path = bindingDef.path;
            var pathElement = path[0];

            var scope;
            var searchScope = targetScope;
            if (pathElement.type != Binding.TYPE_FNC && attrKey == pathElement.name) {
                searchScope = searchScope.$parentScope;
            }

            if (pathElement.type == Binding.TYPE_FNC) {
                scope = searchScope.getScopeForFncName(pathElement.name);
            } else {
                scope = searchScope.getScopeForKey(pathElement.name);
            }

            if(scope){
                if (bindingDef.type !== "static") {
                    var cb;
                    if (_.isFunction(attrKey)) {
                        cb = attrKey;
                    }

                    var twoWay = (bindingDef.type == Binding.TYPE_TWOWAY);


                    var options = {scope: scope, path: path, target: targetScope, twoWay: twoWay, context: context, bindingCreator: this};

                    if (twoWay) {
                        if (bindingDef.transform) {
                            var transformFnc = findTransformFunction(bindingDef.transform, searchScope);
                            if (transformFnc) {
                                options.transform = transformFnc;
                            }
                        }

                        if (bindingDef.transformBack) {
                            var transformBackFnc = findTransformFunction(bindingDef.transformBack, searchScope);
                            if (transformBackFnc) {
                                options.transformBack = transformBackFnc;
                            }
                        }
                    }

                    if (cb) {
                        options['callback'] = cb;
                    } else {
                        options['targetKey'] = attrKey;
                    }
                    return new Binding(options);

                } else {
                    return scope.get(bindingDef.path);
                }
            }else{
                throw "Couldn't find scope for " + pathElement.name;
            }

        },

        evaluate: function (text, scope, attrKey) {
            if (!_.isString(text)) {
                return text;
            }
            var bindingDefs = Parser.parse(text, "text"), binding, bindings = [];
            for (var i = 0; i < bindingDefs.length; i++) {
                var bindingDef = bindingDefs[i];
                if (bindingDef.length) {
                    bindingDefs[i] = bindingDef;
                } else {
                    binding = this.create(bindingDef, scope, attrKey, bindingDefs);
                    if (binding instanceof Binding) {
                        bindings.push(binding);
                    }
                    bindingDefs[i] = binding;
                }

            }

            if (bindings.length > 0) {
                return bindings[0].getContextValue();
            } else if (bindingDefs.length > 0) {
                if (bindingDefs.length === 1) {
                    return bindingDefs[0];
                }
                return Binding.contextToString(bindingDefs);
            } else {
                return text;
            }

        }
    });

});
define('js/core/Bindable',["js/core/EventDispatcher", "js/lib/parser", "js/core/Binding","underscore"],
    function (EventDispatcher, Parser, Binding, _) {

        var indexExtractor = /^(.*)\[(\d+)\]$/,
            undefined, List;

        /** @class */
        var Bindable = EventDispatcher.inherit("js.core.Bindable",
            /** @lends Bindable.prototype */
            {
                /**
                 * @class A Bindable triggers every change of his attributes as 'change' event.
                 * @constructs
                 * @params {Object} attributes a key, value hash
                 */
                ctor: function (attributes) {
                    this.$eventBindables = [];

                    // call the base class constructor
                    this.callBase(null);

                    this.$ = {};

                    _.extend(this._eventAttributes, this.base._eventAttributes || {});

                    attributes = attributes || {};

                    var defaultAttributes = this._defaultAttributes();
                    for (var key in defaultAttributes) {
                        if (defaultAttributes.hasOwnProperty(key)) {
                            if (!attributes.hasOwnProperty(key)) {
                                if (_.isFunction(defaultAttributes[key])) {
                                    // Function as default -> construct new Object
                                    attributes[key] = new (defaultAttributes[key])();
                                } else {
                                    attributes[key] = _.clone(defaultAttributes[key]);
                                }
                            }
                        }
                    }

                    this.$ = attributes;
                    // TODO: clone and keep prototype for attribute the same -> write own clone method
                    this.$previousAttributes = _.clone(attributes);

                },
                /**
                 * Here you can define the default attributes of the instance.
                 *
                 * @static
                 */
                defaults: {
                },

                _defaultAttributes: function () {
                    return this._generateDefaultsChain("defaults");
                },

                _generateDefaultsChain: function (property) {
                    var ret = this[property],
                        base = this.base;

                    while (base) {
                        _.defaults(ret, base[property]);
                        base = base.base;
                    }

                    return ret;
                },

                /**
                 * Call this to set attributes
                 * @param {String} key The attribute key
                 * @param {String} value The attribute value
                 * @param {Object} options A hash of options
                 * @param {Boolean} options.silent If true no event is triggered on change
                 * @param {Boolean} options.unset If true the attribute gets deleted
                 */
                set: function (key, value, options) {
                    var attributes = {};

                    if (_.isString(key)) {
                        // check for path
                        var path = key.split(".");
                        if (path.length > 1) {
                            var scope = this.get(path.shift());
                            if (scope && scope.set) {
                                scope.set(path.join("."), value, options);
                                return this;
                            }

                        }

                        attributes[key] = value;
                    } else {
                        options = value;
                        attributes = key;
                    }

                    options = options || {silent: false, unset: false};

                    // for unsetting attributes
                    if (options.unset) {
                        for (key in attributes) {
                            if (attributes.hasOwnProperty(key)) {
                                attributes[key] = void 0;
                            }
                        }
                    }

                    var changedAttributes = {},
                        now = this.$,
                        val, prev;

                    for (key in attributes) {
                        if (attributes.hasOwnProperty(key)) {
                            // get the value
                            val = attributes[key];
                            // unset attribute or change it ...
                            if (options.unset === true) {
                                delete now[key];
                            } else {
                                if (!_.isEqual(now[key], attributes[key])) {
                                    prev = now[key];
                                    this.$previousAttributes[key] = prev;
                                    now[key] = attributes[key];
                                    changedAttributes[key] = now[key];
                                }
                            }
                            // if attribute has changed and there is no async changing process in the background, fire the event

                        }
                    }

                    this._commitChangedAttributes(changedAttributes);

                    if (options.silent === false && _.size(changedAttributes) > 0) {
                        for (key in changedAttributes) {
                            if (changedAttributes.hasOwnProperty(key)) {
                                this.trigger('change:' + key, changedAttributes[key], this);
                            }
                        }
                        this.trigger('change', changedAttributes, this);
                    }

                    return this;
                },


                /***
                 *
                 * @param {Object} [scope]
                 * @param {String} key
                 * @returns Attribute value
                 */
                get: function(scope, key) {
                    if(!key){
                        key = scope;
                        scope = this;
                    }

                    if(!key) {
                        return null;
                    }

                    var path;

                    // if we have a path object
                    if(_.isArray(key)){
                        path = key;
                    // path element
                    }else if(_.isObject(key)){
                        path = [key];
                    }else{
                        path = Parser.parse(key, "path");
                    }


                    var pathElement;
                    // go through the path
                    while (scope && path.length > 0) {
                        pathElement = path.shift();
                        if (pathElement.type == "fnc") {
                            var fnc = scope[pathElement.name];
                            var parameters = pathElement.parameter;
                            for (var i = 0; i < parameters.length; i++) {
                                var param = parameters[i];
                                if (_.isObject(param)) {
                                    param.type = "static";
                                    parameters[i] = this.get(param.path);
                                }
                            }
                            scope = fnc.apply(scope, parameters);
                        } else if (pathElement.type == "var") {
                            if (scope instanceof Bindable) {
                                if(path.length === 0){
                                    scope = scope.$[pathElement.name];
                                }else{
                                    scope = scope.get(pathElement.name);
                                }

                            } else {
                                scope = scope[pathElement.name];
                            }
                        }

                        if(scope && pathElement.index !== ''){
                            // if it's an array
                            if(_.isArray(scope)){
                                scope = scope[pathElement.index];
                            // if it's a list
                            }else if(scope.at){
                                scope = scope.at(pathElement.index);
                            }
                        }
                    }
                    return scope;
                },

                /**
                 *
                 * @param {String} key
                 * @returns true if attribute is not undefined
                 */
                has: function (key) {
                    return !_.isUndefined(this.get(key));
                },
                /**
                 * This method when attributes have changed after a set
                 * @param {Object} hash of changed attributes
                 */
                _commitChangedAttributes: function (attributes) {
                    // override
                },
                /**
                 * Unsets on attribute key
                 * @param {String} attribute key
                 * @param {Object} options
                 */
                unset: function (key, options) {
                    (options || (options = {})).unset = true;
                    return this.set(key, null, options);
                },
                /***
                 * Clears all attributes
                 */
                clear: function () {
                    return this.set(this.$, {unset: true});
                },
                /***
                 *
                 * @param {String} path a.b.c
                 * @param {String} event
                 * @param {Function} callback
                 * @param {Object} scope
                 */
                bind: function (path, event, callback, scope) {
                    if (event instanceof Function && _.isString(path)) {
                        this.callBase(path, event, callback);
                    } else {
                        if(_.isArray(path) && path.length > 0){
                            scope = callback;
                            callback = event;
                            event = path[1];
                            path = path[2];
                        }
                        var eb = new EventBindable({
                            path: path,
                            event: event,
                            scope: scope,
                            callback: callback,
                            value: null
                        });
                        eb.set('binding', new Binding({path: path, scope: this, target: eb, targetKey: 'value'}));
                        this.$eventBindables.push(eb);
                    }
                },
                /***
                 * Unbinds an event.
                 * @param {String} [path]
                 * @param {String} event
                 * @param {Function} callback
                 * @param {Object} [scope]
                 */
                unbind: function (path, event, callback, scope) {
                    if (event instanceof Function) {
                        this.callBase(path, event, callback);
                    } else {
                        var eb;
                        for (var i = this.$eventBindables.length - 1; i >= 0; i--) {
                            eb = this.$eventBindables[i];
                            if (eb.$.scope === scope && eb.$.path === path && eb.$.event === event && eb.$.callback === callback) {
                                // unbind
                                eb.destroy();
                                this.$eventBindables.slice(i, 1);
                            }
                        }
                    }
                },
                /***
                 * Destroys all event bindings and triggers a destroy event
                 */
                destroy: function() {
                    this.callBase();
                    for(var i = 0; i < this.$eventBindables.length; i++){
                        this.$eventBindables[i].destroy();
                    }

                    this.trigger('destroy',this);
                    return this;
                }
            });

        var EventBindable = Bindable.inherit({
            _commitChangedAttributes: function (attributes) {
                this.callBase();
                this._unbindEvent(this.$previousAttributes['value']);
                if (!_.isUndefined(attributes.value)) {
                    this._bindEvent(attributes.value);
                }
            },
            _unbindEvent: function (value) {
                if (value && value instanceof EventDispatcher) {
                    value.unbind(this.$.event, this.$.callback, this.$.scope);
                }
            },
            _bindEvent: function (value) {
                if (value && value instanceof EventDispatcher) {
                    value.bind(this.$.event, this.$.callback, this.$.scope);
                }
            },
            destroy: function () {
                this._unbindEvent(this.$.value);
                this.$.binding.destroy();

                this.callBase();
            }
        });

        return Bindable;

    });
define('js/core/Element',["js/core/Bindable", "js/core/BindingCreator", "underscore"], function (Bindable, BindingCreator, _) {

        var undefined;
        var bindingCreator = new BindingCreator();

        function stringToPrimitive(str) {
            // if it's not a string
            if (_.isString(str)) {

                var num = Number(str);
                if (!isNaN(num)) {
                    return num;
                }

                if (str === "true") {
                    return true;
                } else if (str === "false") {
                    return false;
                }
            }
            return str;
        }

        var Element = Bindable.inherit("js.core.Element", {
            ctor: function (attributes, descriptor, systemManager, parentScope, rootScope) {

                attributes = attributes || {};

                if (!descriptor) {
                    // created from node
                    if (!rootScope) {
                        rootScope = this;
                    }
                }

                this.$descriptor = descriptor;
                this.$systemManager = systemManager;
                this.$parentScope = parentScope || null;
                this.$rootScope = rootScope || null;
                this.$attributesNamespace = this.$attributesNamespace || {};
                this.$bindingCreator = bindingCreator;

                this.callBase(attributes);

                this._initializeAttributes(this.$);

                // manually constructed
                if (descriptor === undefined || descriptor === null) {
                    this._initialize(this.$creationPolicy);
                }

            },

            _getAttributesFromDescriptor: function (descriptor) {

                this.$attributesNamespace = this.$attributesNamespace || {};

                var attributes = {};

                if (descriptor && descriptor.attributes) {
                    var node, localName;

                    for (var a = 0; a < descriptor.attributes.length; a++) {
                        node = descriptor.attributes[a];
                        // don't add xmlns attributes
                        if(node.nodeName.indexOf("xmlns") !== 0){
                            localName = this._getLocalNameFromNode(node);
                            attributes[localName] = stringToPrimitive(node.value);

                            if (node.namespaceURI) {
                                this.$attributesNamespace[localName] = node.namespaceURI;
                            }

                        }

                    }
                }

                return attributes;
            },
            _getLocalNameFromNode: function(node){
                return node.localName ? node.localName : node.name.split(":").pop();
            },
            defaults: {
                creationPolicy: "auto"
            },

            _initializeAttributes: function (attributes) {
            },

            _initializeDescriptors: function () {
            },

            /**
             *
             * @param creationPolicy
             *          auto - do not overwrite (default),
             *          all - create all children
             *          TODO none?
             */
            _initialize: function (creationPolicy, withBindings) {
                if (this.$initialized) {
                    return;
                }

                this._preinitialize();

                this.initialize();

                this._initializeDescriptors();

                if (this == this.$rootScope || withBindings) {
                    this._initializeBindings();
                }

            },

            _initializeBindings: function () {
                this._initializationComplete();
            },
            initialize: function () {

            },
            find: function (key) {
                var scope = this.getScopeForKey(key);
                if (this === scope) {
                    return this.get(key);
                } else if (scope != null) {
                    return scope.get(key);
                } else {
                    return null;
                }
            },
            getScopeForKey: function (key) {
                // try to find value for first key
                var value = this.$[key];

                // if value was found
                if (!_.isUndefined(value)) {
                    return this;
                } else if (this.$parentScope) {
                    return this.$parentScope.getScopeForKey(key);
                } else {
                    return null;
                }
            },
            getScopeForFncName: function (fncName) {
                var fnc = this[fncName];
                if (!_.isUndefined(fnc) && _.isFunction(fnc)) {
                    return this;
                } else if (this.$parentScope) {
                    return this.$parentScope.getScopeForFncName(fncName);
                } else {
                    return null;
                }
            },
            _preinitialize: function () {

            },
            _initializationComplete: function () {

                // call commitChangedAttributes for all attributes
                this._commitChangedAttributes(this.$);

                this.$initialized = true;
            },
            _getTextContentFromDescriptor: function (desc) {
                var textContent = desc.textContent || desc.text || desc.data;
                if (!textContent) {
                    textContent = "";
                    for (var i = 0; i < desc.childNodes.length; i++) {
                        var node = desc.childNodes[i];
                        // element or cdata node
                        if (node.nodeType == 1 || node.nodeType == 4) {
                            textContent += this._getTextContentFromDescriptor(node);
                        }
                    }
                }
                return textContent;
            }
        });

        Element.xmlStringToDom = function(xmlString) {

            if (window && window.DOMParser) {
                return (new DOMParser()).parseFromString(xmlString, "text/xml").documentElement;
            } else if (typeof(ActiveXObject) !== "undefined") {
                var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(xmlString);
                return xmlDoc.documentElement;
            } else {
                throw "Couldn't parse xml string";
            }


        };

        return Element;
    }
);
define('js/core/TextElement',["js/core/Element", "underscore"], function (Element, _) {

        return Element.inherit("js.core.TextElement", {
            _initializeBindings: function () {
                this.$.textContent = this.$bindingCreator.evaluate(this.$.textContent || "", this, "textContent");
                this.callBase();
            },
            _initializeDescriptors: function(){
                if (this.$descriptor) {
                    this.$.textContent = this._getTextContentFromDescriptor(this.$descriptor);
                }
            },
            render: function () {
                if (!this.$initialized) {
                    this._initialize(this.$creationPolicy);
                }

                this.$el = this.$systemManager.$document.createTextNode("");
                this._renderTextContent(this.$.textContent);


                return this.$el;
            },
            _renderTextContent: function (textContent) {
                if(_.isUndefined(this.$.textContent) || textContent === null){
                    textContent = "";
                }
                this.$el.nodeValue = textContent;

            },
            _commitChangedAttributes: function (attributes) {
                if (this.$el) {
                    if (!_.isUndefined(attributes.textContent)) {
                        this._renderTextContent(attributes.textContent);
                    }
                }
            }
        });
    }
);
define('js/core/Component',["require", "js/core/Element", "js/core/TextElement", "js/core/Bindable", "js/core/EventDispatcher", "underscore"],

    function (require, Element, TextElement, Bindable, EventDispatcher, _) {

        var Template,
            Configuration;


        var Component = Element.inherit("js.core.Component",
            /** @lends Component */
            {
                /***
                 * What up??
                 * @param attributes The attributes of the component
                 * @param {String} attributes.style The style of the component
                 * @param {Node} descriptor
                 * @param {SystemManager} systemManager
                 * @param {Element} parentScope
                 * @param {Element} rootScope
                 * @constructs
                 */
                ctor: function (attributes, descriptor, systemManager, parentScope, rootScope) {
                    if (_.isUndefined(Template)) {
                        try {
                            Template = require('js/core/Template');
                        } catch(e) {
                            Template = null;
                        }
                    }

                    if (_.isUndefined(Configuration)) {
                        try {
                            Configuration = require('js/conf/Configuration');
                        } catch(e) {
                            Configuration = null;
                        }
                    }
                    this.$eventDefinitions = [];
                    this.$internalDescriptors = [];
                    this.$xamlDefaults = {};
                    this.$xamlAttributes = {};
                    var current = this, last;
                    while (current) {
                        if (current._$descriptor && last != current) {
                            this._cleanUpDescriptor(current._$descriptor);
                            this.$internalDescriptors.unshift(current._$descriptor);

                            _.extend(this.$xamlDefaults, this._getAttributesFromDescriptor(current._$descriptor));
                        }
                        current = current.base;
                    }

                    if (descriptor) {
                        this._cleanUpDescriptor(descriptor);
                        this.$xamlAttributes = this._getAttributesFromDescriptor(descriptor);
                    }

                    this.$elements = [];

                    this.$templates = {};
                    this.$configurations = [];
                    this.$children = [];

                    attributes = attributes || {};
                    _.extend(attributes, this.$xamlAttributes, this.$xamlDefaults);

                    this.callBase();
                },

                /**
                 * @name Component#ontest
                 * @event
                 * @param {Event} e Custom Event
                 * @param {String} e.$.value Your value
                 *
                 */
                events: [
                ],
                /**
                 * values to be injected
                 * @key {String} name of the variable for this.$key
                 * @value {Required Class}
                 */
                inject: {},
                _injectChain: function () {
                    return this._generateDefaultsChain("inject");
                },
                _preinitialize: function () {
                    this.callBase();

                    this._inject();
                    this._bindBus();
                },

                _bindBus: function() {
                    for (var f in this) {
                        var fn = this[f];
                        if (fn instanceof Function && fn._busEvents) {
                            for (var i = 0; i < fn._busEvents.length; i++) {
                                this.$systemManager.$bus.bind(fn._busEvents[i], fn, this);
                            }
                        }
                    }
                },

                _inject: function () {

                    var inject = this._injectChain();

                    if (_.keys(inject).length > 0) {
                        // we need to inject at least on item

                        // synchronous singleton instantiation of Injection,
                        // because if module requires injection, application also depends on
                        // Injection.js and class should be installed.
                        var injection = this.$systemManager.$injection;
                        if (injection) {
                            for (var name in inject) {
                                if (inject.hasOwnProperty(name)) {
                                    this.$[name] = injection.getInstance(inject[name]);
                                }
                            }
                        } else {
                            throw "injection not available in systemManager";
                        }

                    }

                },
                addChild: function (child) {
                    if (!(child instanceof Element)) {
                        throw "only children of type js.core.Component can be added"
                    }

                    // initialize auto
                    if (this.$creationPolicy == "auto") {
                        child._initialize(this.$creationPolicy);
                    }

                    if (child.$rootScope && child.$.cid) {
                        // register component by cid in the root scope
                        child.$rootScope.set(child.$.cid, child);
                    }

                    child.$parent = this;
                    // save under elements
                    this.$elements.push(child);

                    // handle special elements
                    if (Template && child instanceof Template) {
                        this._addTemplate(child);
                    } else if (Configuration && child instanceof Configuration) {
                        this._addConfiguration(child);
                    }
                },

                removeChild: function (child) {
                    if (!(child instanceof Element)) {
                        throw "only children of type js.core.Component can be removed"
                    }

                    var index = this.$elements.indexOf(child);
                    if (index != -1) {
                        // child found
                        child.$parent = null;
                        this.$elements.splice(index, 1);
                    }

                    if (this.$templates.hasOwnProperty(child.$.name)) {
                        // remove it from templates
                        delete this.$templates[child.$.name];
                    }

                    index = this.$elements.indexOf(child);
                    if (index != -1) {
                        this.$configurations.splice(index, 1);
                    }

                },

                _addTemplate: function (template) {
                    if (!template.$.name) {
                        throw "template without name";
                    }
                    this.$templates[template.$.name] = template;
                },

                _addConfiguration: function (config) {
                    this.$configurations.push(config);
                },

                getTemplate: function (name) {
                    var tpl = this.$templates[name];
                    if (tpl) {
                        return tpl;
                    } else if (this.$parent && this.$parent != this) {
                        return this.$parent.getTemplate(name);
                    } else {
                        return null
                    }
                },
                _initializeChildren: function (childComponents) {
                    for (var i = 0; i < childComponents.length; i++) {
                        // add the children
                        this.addChild(childComponents[i]);
                    }
                },
                /***
                 *
                 * @param attributes
                 */
                _initializeAttributes: function (attributes) {
                    this.callBase();

                    if (this.$creationPolicy != "full") {
                        if (attributes.hasOwnProperty("creationPolicy")) {
                            this.$creationPolicy = attributes.creationPolicy;
                            delete attributes.creationPolicy;
                        }
                    }

                },
                /***
                 *  Initializes all internal and external descriptors
                 */
                _initializeDescriptors: function () {
                    var children = [];

                    var desc;
                    for (var d = 0; d < this.$internalDescriptors.length; d++) {
                        desc = this.$internalDescriptors[d];
                        children = children.concat(this._getChildrenFromDescriptor(desc, this));
                    }

                    children = children.concat(this._getChildrenFromDescriptor(this.$descriptor));

                    this._initializeChildren(children);

                    this._childrenInitialized();

                    this._initializeEventAttributes(this.$xamlDefaults, this);
                    this._initializeEventAttributes(this.$xamlAttributes, this.$rootScope);
                },
                _cleanUpDescriptor: function (desc) {
                    if (desc && desc.childNodes) {
                        var node, text;
                        // remove empty text nodes
                        for (var i = desc.childNodes.length - 1; i >= 0; i--) {
                            node = desc.childNodes[i];
                            if (node.nodeType === 3) {
                                text = node.textContent || node.text || node.data;
                                if (!text || text.trim().length === 0) {
                                    desc.removeChild(node);
                                }

                            }
                        }
                    } else {
                        console.warn("Descriptor not defined or not correct");
                    }
                },
                /**
                 * an array of attributes names, which will expect handler functions
                 */
                _isEventAttribute: function (attributeName) {
                    return attributeName.indexOf("on") == 0;
                    // return this._eventAttributes.hasOwnProperty(attributeName);
                },
                /**
                 * Returns true if event is defined in Component event list
                 * @param event
                 */
                _isComponentEvent: function (event) {
                    for (var i = 0; i < this.events.length; i++) {
                        if (event == this.events[i]) {
                            return true;
                        }
                    }
                    return false;
                },
                _getEventTypeForAttribute: function (eventName) {
                    // TODO: implement eventAttribites as hash
                    return this._eventAttributes[eventName];
                },
                _initializeEventAttributes: function (attributes, rootScope) {
                    var event = '';
                    for (var key in attributes) {
                        if (attributes.hasOwnProperty(key)) {
                            var value = attributes[key];

                            if (this._isEventAttribute(key)) {
                                if (rootScope[value]) {

                                    this.$eventDefinitions.push({
                                        name: key,
                                        scope: rootScope,
                                        fncName: value
                                    });
                                    event = key.substr(2);
                                    if (this._isComponentEvent(event)) {
                                        this.bind(event, rootScope[value], rootScope);
                                    }

                                } else {
                                    throw "Couldn't find callback " + value + " for " + key + " event";
                                }
                            }
                        }
                    }
                },
                /***
                 * Initialize all Binding and Event attributes
                 */
                _initializeBindings: function () {
                    var attributes = this.$;

                    var value;
                    // Resolve bindings and events
                    for (var key in attributes) {

                        if (attributes.hasOwnProperty(key)) {
                            value = attributes[key];
                            this.$[key] = this.$bindingCreator.evaluate(value, this, key);
                        }
                    }

                    for (var c = 0; c < this.$elements.length; c++) {
                        this.$elements[c]._initializeBindings();
                    }

                    this.callBase();
                },
                /***
                 * Create {@link Component} for DOM Node with given attributes
                 * @param DOM Node
                 * @param attributes for new Component
                 */
                _createComponentForNode: function (node, attributes, rootScope) {
                    if (!node) return null;

                    attributes = attributes || {};
                    rootScope = rootScope || this.$rootScope;
                    // only instantiation and construction but no initialization
                    var appDomain = this.$systemManager.$applicationDomain;

                    if (node.nodeType == 1) { // Elements

                        var fqClassName = this.$systemManager.$applicationContext.getFqClassName(node.namespaceURI, this._localNameFromDomNode(node), true);
                        var className = this.$systemManager.$applicationContext.getFqClassName(node.namespaceURI, this._localNameFromDomNode(node), false);

                        return this.$systemManager.$applicationContext.createInstance(fqClassName, [attributes, node, this.$systemManager, this, rootScope], className);

                    } else if (node.nodeType == 3 || node.nodeType == 4) { // Textnodes
                        // remove whitespaces from text textnodes
                        var text = node.textContent ? node.textContent : node.text;
                        if (node.textContent) {
                            node.textContent = text;
                        }
                        // only instantiation and construction but no initialization
                        return this._createTextElement(node, rootScope);
                    }

                    return null;
                },

                createComponent: function(factory, attributes) {
                    attributes = attributes || [];
                    return this.$systemManager.$applicationContext.createInstance(factory, [attributes, null, this.$systemManager, this, this.$rootScope]);
                },

                _createTextElement: function(node, rootScope) {
                    return this.$systemManager.$applicationContext.createInstance('js/core/TextElement', [null, node, this.$systemManager, this, rootScope]);
                },

                /***
                 * Converts all child nodes of a descriptor to instances of Components or TextElement
                 * @param descriptor
                 */
                _getChildrenFromDescriptor: function (descriptor, rootScope) {
                    var childrenFromDescriptor = [], node, component;

                    if (descriptor) {
                        for (var i = 0; i < descriptor.childNodes.length; i++) {
                            node = descriptor.childNodes[i];
                            component = this._createComponentForNode(node, null, rootScope);
                            if (component) {
                                childrenFromDescriptor.push(component);
                            }
                        }
                    }

                    return childrenFromDescriptor;
                },
                /***
                 * @private
                 * This method is called after all children are initialized
                 */
                _childrenInitialized: function () {

                },
                /***
                 * This method should overridden by custom components to set initial variables
                 * @param scope
                 */
                initialize: function (scope) {
                },
                /**
                 * IE8 FIXES
                 * @param domNode
                 */
                _localNameFromDomNode: function (domNode) {
                    if (domNode.localName) return domNode.localName;

                    var st = domNode.tagName.split(":");
                    return st[st.length - 1];
                }
            });

        return Component;
    }
);
define('js/core/Content',["require","js/core/Component"], function (require,Component) {
    return Component.inherit("js.core.Content", {
        getChildren: function(){
            var el, children = [];
            for(var i = 0; i < this.$elements.length; i++){
                el = this.$elements[i];
                if(el instanceof require("js/core/DomElement")){
                    children.push(el);
                }
            }
            return children;
        }
    });
});
define('js/core/DomElement',["require", "js/core/EventDispatcher","js/core/Component", "js/core/Content", "js/core/Binding", "inherit", "underscore"],
    function (require, EventDispatcher, Component, Content, Binding, inherit, _) {

        var rspace = /\s+/;

        var ContentPlaceHolder;

        var DomElementFunctions = {

            $classAttributes: [
                /^\$/,
                /^data/,
                /^xmlns/,
                /^on/,
                "cid",
                /^_/ // private attributes
            ],

            ctor: function (attributes, descriptor, systemManager, parentScope, rootScope) {
                this.$renderMap = {};
                this.$children = [];
                this.$contentChildren = [];
                this.$domEventHandler = {};
                // go inherit tree up and search for descriptors
                var current = this;
                while (current) {
                    if (current.$classAttributes) {
                        this.$classAttributes = this.$classAttributes.concat(current.$classAttributes);
                    }
                    current = current.base;
                }


                this.callBase();

                if (descriptor) {
                    if (!this.$tagName) {
                        this.$tagName = descriptor.tagName;
                    }
                    if (!this.$namespace) {
                        this.$namespace = descriptor.namespaceURI;
                    }
                }
            },

            _inject: function () {
                this.callBase();

                var inject = this._injectChain();

                for (var name in inject) {
                    if (inject.hasOwnProperty(name)) {
                        this.$classAttributes.push(name);
                    }
                }

            },

            _initializeAttributes: function (attributes) {
                this.callBase();

                if (attributes.tagName) {
                    this.$tagName = attributes.tagName;
                    delete(attributes.tagName);
                }

                if (attributes.namespace) {
                    this.$namespace = attributes.namespace;
                    delete (attributes.namespace);
                }
            },

            addChild: function (child) {
                this.callBase();

                if (child instanceof DomElement || child.render) {
                    this.$children.push(child);
                    if (this.isRendered()) {
                        this._renderChild(child);
                    }
                } else if (child instanceof Content) {
                    this.$contentChildren.push(child);
                }
            },

            removeChild: function (child) {
                this.callBase();
                if (child instanceof DomElement || child.render) {
                    if (this.isRendered()) {
                        this._removeRenderedChild(child);
                    }
                    var i = this.$children.indexOf(child);
                    this.$children.splice(i, 1);
                }
            },

            getPlaceHolder: function (name) {
                for (var i = 0; i < this.$children.length; i++) {
                    if (this.$children[i].$.name === name) {
                        return this.$children[i];
                    }
                }
                var placeholder;
                for (i = 0; i < this.$children.length; i++) {
                    if (this.$children[i].getPlaceHolder) {
                        placeholder = this.$children[i].getPlaceHolder(name);
                        if (placeholder) {
                            return placeholder;
                        }
                    }

                }
                return null;
            },

            remove: function () {
                if (this.$parent) {
                    this.$parent.removeChild(this);
                }
            },

            getContentPlaceHolders: function () {

                if (!ContentPlaceHolder) {
                    ContentPlaceHolder = require('js/ui/ContentPlaceHolder');
                }

                var ret = [];

                var child;
                for (var i = 0; i < this.$children.length; i++) {
                    child = this.$children[i];

                    if (ContentPlaceHolder && child instanceof ContentPlaceHolder) {
                        ret.push(child);
                    } else if (child instanceof DomElement) {
                        ret = ret.concat(child.getContentPlaceHolders());
                    }
                }

                return ret;

            },

            findContent: function (name) {

                var child,
                    content;

                for (var i = 0; i < this.$elements.length; i++) {
                    child = this.$elements[i];
                    if (child instanceof Content && child.$.name === name) {
                        return child;
                    }
                }

                for (i = 0; i < this.$elements.length; i++) {
                    child = this.$elements[i];
                    if (child.findContent) {
                        content = child.findContent(name);
                        if (content) {
                            return content;
                        }
                    }

                }

                return null;
            },

            render: function () {

                if (!this.$initialized) {
                    this._initialize(this.$creationPolicy);
                }
                // check if it is already rendered
                if (this.isRendered()) {
                    return this.$el;
                }

                this.$renderedChildren = [];

                if (this.$systemManager.$document.createElementNS && this.$namespace && /^http/.test(this.$namespace)) {
                    this.$el = this.$systemManager.$document.createElementNS(this.$namespace, this.$tagName);
                } else {
                    this.$el = this.$systemManager.$document.createElement(this.$tagName);
                }

                this._initializeRenderer(this.$el);
                this._renderChildren(this.$children);
                this._renderContentChildren(this.$contentChildren);
                this._renderAttributes(this.$);
                this._bindDomEvents(this.$el);

                return this.$el;
            },
            _bindDomEvents: function (el) {
                var eventDef, es;

                for (var i = 0; i < this.$eventDefinitions.length; i++) {
                    eventDef = this.$eventDefinitions[i];
                    es = eventDef.name.substr(2);
                    this.bind(es, eventDef.scope[eventDef.fncName], eventDef.scope);
                }
            },

            _initializeRenderer: function (el) {
                // hook
            },

            _renderChildren: function (children) {
                // for all children
                var child;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    this._renderChild(child);
                }
            },

            _renderContentChildren: function (children) {
                var child;
                for (var i = 0; i < children.length; i++) {
                    child = children[i];
                    var ref = child.get('ref');
                    var placeHolder = this.getPlaceHolder(ref);
                    if (placeHolder) {
                        placeHolder.set({content: child});
                    }
                }
            },

            _renderChild: function (child) {
                if (_.isFunction(child.render)) {
                    var el = child.render();
                    this.$renderedChildren.push(child);
                    if (el) {
                        this.$el.appendChild(el);
                    }
                }
            },

            _removeRenderedChild: function (child) {
                if (this.isRendered()) {
                    var rc;
                    for (var i = this.$renderedChildren.length - 1; i >= 0; i--) {
                        rc = this.$renderedChildren[i];
                        if (child === rc) {
                            this.$el.removeChild(rc.$el);
                            this.$renderedChildren.splice(i, 1);
                            return;
                        }
                    }
                }
            },

            _clearRenderedChildren: function () {
                if (this.isRendered()) {
                    var rc;
                    for (var i = this.$renderedChildren.length - 1; i >= 0; i--) {
                        rc = this.$renderedChildren[i];
                        this.$el.removeChild(rc.$el);
                    }
                }
                this.$renderedChildren = [];
            },

            _getIndexOfPlaceHolder: function (placeHolder) {
                if (this.$layoutTpl) {
                    var child;
                    for (var i = 0; i < this.$layoutTpl.$children.length; i++) {
                        child = this.$layoutTpl.$children[i];
                        if (placeHolderId == child.$cid) {
                            return i;
                        }
                    }
                }
                return -1;
            },

            isRendered: function () {
                return typeof (this.$el) !== "undefined";
            },

            _renderAttributes: function (attributes) {
                var attr;
                for (var key in attributes) {
                    if (attributes.hasOwnProperty(key)) {
                        attr = attributes[key];
                        this._renderAttribute(key, attr);
                    }
                }
            },

            _renderAttribute: function (key, attr) {
                var method = this.$renderMap[key];
                var prev = this.$previousAttributes[key];

                if (_.isUndefined(method)) {
                    // generic call of render functions

                    var k = key.charAt(0).toUpperCase() + key.substr(1);
                    var methodName = "_render" + k;
                    method = this[methodName];

                    if (!_.isFunction(method)) {
                        method = false;
                    }

                    this.$renderMap[key] = method;
                }
                if (method !== false) {
                    method.call(this, attr, prev);
                } else {
                    var cAttr;
                    for (var i = 0; i < this.$classAttributes.length; i++) {
                        cAttr = this.$classAttributes[i];
                        if (cAttr instanceof RegExp) {
                            if (cAttr.test(key)) {
                                return;
                            }
                        } else {
                            if (cAttr == key) {
                                return;
                            }
                        }
                    }
                    this._setAttribute(key, attr);
                }
            },
            _setAttribute: function (key, value, namespaceUri) {

                if (!_.isUndefined(value)) {

                    namespaceUri = namespaceUri || this.$attributesNamespace[key];

                    if (this.$el.setAttributeNS && namespaceUri) {
                        this.$el.setAttributeNS(namespaceUri, key, value)
                    } else {
                        this.$el.setAttribute(key, value);
                    }
                }
            },


            _commitChangedAttributes: function (attributes) {
                if (this.isRendered()) {
                    this._renderAttributes(attributes);
                }
            },
            destroy: function () {
                this.callBase();

                if (this.$children) {
                    for (var i = 0; i < this.$children.length; i++) {
                        this.$children[i].destroy();
                    }
                }
            },
            html: function () {
                if (!this.isRendered()) {
                    this.render();
                }
                return this.$el.innerHTML;

            }.on('change'),
            dom: function (element) {
                return new DomManipulation(element || this);
            },
            setChildIndex: function (child, index) {
                if(index < 0){
                    index += this.$children.length;
                }
                if(index >= this.$children.length ){
                    index -= this.$children.length;
                }
                var oldIndex = this.$children.indexOf(child);
                if (oldIndex !== index) {
                    this.$children.splice(oldIndex, 1);
                    this.$children.splice(index, 0, child);
                    if (this.isRendered() && child.isRendered()) {
                        if (this.$renderedChildren.length > 1) {
                            this.$el.removeChild(child.$el);
                            if (index < this.$el.childNodes.length) {
                                this.$el.insertBefore(child.$el, this.$el.childNodes[index]);
                            } else {
                                this.$el.appendChild(child.$el);
                            }
                        }
                    }
                }
            },
            bringToFront: function () {
                if (this.$parent) {
                    this.$parent.setChildIndex(this, this.$parent.$children.length - 1);
                }
            },
            sendToBack: function () {
                if (this.$parent) {
                    this.$parent.setChildIndex(this, 0);
                }
            },
            bind: function (type, eventHandler, scope) {
                var self = this;
                this.callBase();
                if (this.isRendered() && !this.$domEventHandler[type] && !this._isComponentEvent(type))  {
                    var cb = this.$domEventHandler[type] = function (originalEvent) {
                        var e = new DomElement.Event(originalEvent);
                        try {
                            self.trigger(type, e, self);
                        } catch(e) {}
                        if (e.isPropagationStopped) {
                            return false;
                        }
                    };
                    this.bindDomEvent(type,cb);
                }
            },

            unbind: function (type, handle, scope) {
                this.callBase();
                var handlers = this._eventHandlers[type];
                if (handlers && handlers.length === 0) {
                    var cb = this.$domEventHandler[type];
                    if(cb){
                        this.unbindDomEvent(type,cb);
                    }
                }
            }
        };

        var DomManipulationFunctions = {
            hasClass: function (value) {
                return this.$el.className.split(" " + value + " ").length != 1;
            },
            addClass: function (value) {
                var classNames = value.split(rspace);

                if (!this.$el.className && classNames.length === 1) {
                    this.$el.className = value;
                } else {
                    var setClasses = this.$el.className.split(rspace);

                    for (var i = 0; i < classNames.length; i++) {
                        if (setClasses.indexOf(classNames[i]) == -1) {
                            setClasses.push(classNames[i]);
                        }
                    }

                    this.$el.className = setClasses.join(" ");

                }
            },

            removeClass: function (value) {

                if (!(this.$el.className && this.$el.className.length !== 0)) {
                    return;
                }
                var removeClasses = value.split(rspace);

                var classes = this.$el.className.split(rspace);

                for (var i = 0; i < removeClasses.length; i++) {
                    var index = classes.indexOf(removeClasses[i]);
                    if (index != -1) {
                        classes.splice(index, 1);
                    }
                }

                if (classes.length === 0) {
                    this.$el.removeAttribute('class');
                } else {
                    this.$el.className = classes.join(" ");
                }
            },
            bindDomEvent: function (type, cb) {
                if (this.$el.addEventListener) {
                    this.$el.addEventListener(type, cb, false);

                } else if (this.$el.attachEvent) {
                    this.$el.attachEvent("on" + type, cb);
                }
            },
            unbindDomEvent: function (type, cb) {
                if (this.$el.removeEventListener) {
                    this.$el.removeEventListener(type, cb, false);
                } else if (this.$el.detachEvent) {
                    this.$el.detachEvent("on" + type, cb);
                }
            }
        };

        var DomManipulation = inherit.Base.inherit(_.extend({
            ctor: function (elm) {
                this.$el = elm;
            }
        }, DomManipulationFunctions));

        var DomElement = Component.inherit("js.html.DomElement",
            _.extend(DomElementFunctions, DomManipulationFunctions));

        DomElement.Event = EventDispatcher.Event.inherit({
            ctor: function (domEvent) {
                this.domEvent = domEvent;
                this.callBase(domEvent);
            },
            stopPropagation: function () {
                this.callBase();

                var e = this.domEvent;
                if (e) {
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                    e.cancelBubble = true;
                }
            },
            preventDefault: function () {
                this.callBase();
                var e = this.domEvent;
                if (e) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;  // IE
                    }
                }
            }
        });

        return DomElement;
    }
);
define('js/html/HtmlElement',['js/core/DomElement'], function(DomElement) {

    var HTML_Namespace = "http://www.w3.org/1999/xhtml";

    var HtmlElement = DomElement.inherit("js/html/HtmlElement", {

        defaults: {
            selected: undefined,
            selectable: undefined,
            namespace: HTML_Namespace
        },

        _renderVisible: function (visible) {
            if (visible === true) {
                this.removeClass('hide');
            } else if (visible === false) {
                this.addClass('hide');
            }
        },

        _renderHidden: function (hidden) {
            if (typeof(hidden) !== "undefined") {
                this.set({visible: !hidden});
            }
        },

        _renderSelected: function (selected) {
            if (selected === true) {
                this.addClass('active');
            } else if (selected === false) {
                this.removeClass('active');
            }
        },

        _renderSelectable: function (selectable) {
            if (selectable === true) {
                if (!this._onSelect) {
                    var self = this;
                    this._onSelect = function () {
                        self.set({selected: !self.$.selected});
                    };
                }
                this.bindDomEvent('click', this._onSelect);
            } else {
                if (this._onSelect) {
                    this.unbindDomEvent('click', this._onSelect);
                }
            }
        },
        _renderWidth: function (width) {
            if (width) {
                if (typeof(width) !== "string") {
                    width += "px";
                }
                this.$el.style.width = width;
            }
        },
        _renderHeight: function (height) {
            if (height) {
                if (typeof(height) !== "string") {
                    height += "px";
                }
                this.$el.style.height = height;
            }
        }

    });

    HtmlElement.HTML_Namespace = HTML_Namespace;

    return HtmlElement;
});
define('js/core/UIComponent',["js/html/HtmlElement"], function (HtmlElement) {
    return HtmlElement.inherit("js.core.UIComponent", {
        defaults: {
            tagName: "div"
        }
    });
});
/*!
 * flow.js JavaScript Library v0.2.2
 * https://github.com/it-ony/flow.js
 *
 * Copyright 2012, Tony Findeisen
 * Licensed under the MIT license.
 * https://raw.github.com/it-ony/flow.js/master/LICENSE
 *
 * Date: Mon Mar 12 2012 12:36:34 GMT+0100 (CET)
 */
(function (exports) {
    

    var Flow = function (context) {
        this.$context = context || {
            actions: [],
            vars: {}
        };
    };

    var flow = function () {
        return new Flow();
    };

    /**
     *
     * @param {String} [name] variable name
     * @param {Function} fn function to execute
     *      fn - function() {}      // syncron
     *      fn - function(cb) {}    // asyncron
     */
    Flow.prototype.seq = function (name, fn) {
        if (name instanceof Function) {
            fn = name;
            name = null;
        }

        if (!fn) {
            throw "Sequence action not defined";
        }

        var self = this;

        this.$context.actions.push(function (cb) {

                var sync_end = false,
                    returned = false;

                var setDataAndReturn = function (err, data, end) {
                    if (!err && name) {
                        // save result to var
                        self.$context.vars[name] = data;
                    }

                    if (returned) {
                        return;
                    }

                    returned = true;
                    cb(err, end);
                };

                /**
                 * @param err
                 * @param data
                 */
                var thisArg = function (err, data) {
                    setDataAndReturn(err, data, false);
                };
                thisArg.vars = self.$context.vars;


                if (fn.length) {
                    // end for async case
                    thisArg.end = function (err, data) {
                        // end
                        setDataAndReturn(err, data, true);
                    };

                    try {
                        fn.call(thisArg, thisArg);
                    } catch (e) {
                        setDataAndReturn(e, null);
                    }
                } else {
                    // sync
                    thisArg.end = function () {
                        sync_end = true;
                    };

                    try {
                        setDataAndReturn(null, fn.call(thisArg), sync_end);
                    } catch (e) {
                        setDataAndReturn(e, null, sync_end);
                    }
                }
            }
        );

        return this;
    };

    var ParallelAction = function (name, fn) {

        if (!fn) {
            throw "Parallel action not defined";
        }

        return function (parallelInstance, context, results, parallelFinishedCallback) {

            var sync_end = false;

            var setDataAndReturn = function (err, data, end) {
                if (!err && name) {
                    // save result to tmp. var
                    results[name] = data;
                }

                parallelFinishedCallback(parallelInstance, err, end);
            };

            var thisArg = function (err, data) {
                setDataAndReturn(err, data, false);
            };

            thisArg.vars = context.vars;

            if (fn.length) {
                // async
                thisArg.end = function (err, data) {
                    // end
                    setDataAndReturn(err, data, true);
                };

                try {
                    fn.call(thisArg, thisArg);
                } catch (e) {
                    setDataAndReturn(e, null);
                }
            } else {
                // sync
                thisArg.end = function () {
                    sync_end = true;
                };

                try {
                    setDataAndReturn(null, fn.call(thisArg), sync_end);
                } catch (e) {
                    setDataAndReturn(e, null, sync_end);
                }
            }
        };
    };

    /**
     * Executes the given functions parallel
     *
     * @param {Object|Array} fns
     *  {Object} fns - keys will be variable name for returned value
     */
    Flow.prototype.par = function (fns) {

        if (arguments.length > 1) {
            // parallel functions given comma separated without named return
            this.par(Array.prototype.slice.call(arguments));
            return this;
        }

        var self = this, i, key;

        if (fns) {

            var parallelActions = [];

            if (fns instanceof Array) {
                for (i = 0; i < fns.length; i++) {
                    var fn = fns[i];
                    parallelActions.push(new ParallelAction(null, fn));
                }
            } else if (fns instanceof Function) {
                this.par([fns]);
            } else {
                for (key in fns) {
                    if (fns.hasOwnProperty(key)) {
                        parallelActions.push(new ParallelAction(key, fns[key]));
                    }
                }
            }

            if (parallelActions.length > 0) {
                // we got at least one function executing in parallel

                // push new action
                this.$context.actions.push(function (cb) {

                    (function (parallelActions, cb) {
                        var results = {}, p;

                        var parallelFinished = function (fn, err, end) {
                            var key;

                            if (!cb) {
                                // callback, already called, because end called multiple times
                                return;
                            }

                            if (err || end) {
                                // some error occurred
                                var cb2 = cb;
                                cb = null;
                                cb2(err, end);
                            } else {
                                var index = parallelActions.indexOf(fn);
                                if (index >= 0 && index < parallelActions.length) {
                                    // remove parallel executed function from actions
                                    parallelActions.splice(index, 1);
                                } else {
                                    cb("Parallel function returned which wasn't part of this parallel actions");
                                    cb = null;
                                    return;
                                }

                                if (parallelActions.length === 0) {
                                    // copy results to var
                                    for (key in results) {
                                        if (results.hasOwnProperty(key)) {
                                            self.$context.vars[key] = results[key];
                                        }
                                    }

                                    cb(null, false);
                                    cb = null;
                                }
                            }
                        };

                        // copy array of parallel actions, to avoid array is modified by returning of function
                        // before all functions are started

                        var copyParallelActions = parallelActions.slice();

                        // start all functions
                        for (p = 0; p < copyParallelActions.length; p++) {
                            // start parallel action
                            var parallelInstance = copyParallelActions[p];
                            parallelInstance(parallelInstance, self.$context, results, parallelFinished);
                        }
                    }(parallelActions, cb));

                });
            }
        }

        return this;
    };

    /***
     * executes the given function for each value in values
     * @param {Array|Object} values for which fn should be called in parallel,
     *                      if object is passed, keys will be var names
     * @param {Function} fn function which will be executed for each value in values
     *                      function(value, [cb]) - the function will be called with the value as first parameter
     *                      and optional as second parameter with the callback
     */
    Flow.prototype.parEach = function (values, fn) {
        values = values || [];

        if (!(fn instanceof Function)) {
            throw "2nd argument for parEach needs to be a function";
        }

        var noVars = values instanceof Array,
            delegates = noVars ? [] : {};

        function addDelegate(name, value) {
            if (noVars) {
                value = name;
                name = null;
            }

            var parFn;

            if (fn.length >= 2) {
                // async
                parFn = function (cb) {
                    fn(value, cb);
                };
            } else {
                // sync
                parFn = function () {
                    return fn(value);
                };
            }

            if (noVars) {
                delegates.push(parFn);
            } else {
                delegates[name] = parFn;
            }

        }

        if (noVars) {
            for (var i = 0; i < values.length; i++) {
                addDelegate(values[i]);
            }
        } else {
            for (var key in values) {
                if (values.hasOwnProperty(key)) {
                    addDelegate(key, values[key]);
                }
            }
        }

        return this.par(delegates);
    };


    Flow.prototype.seqEach = function (values, fn) {
        values = values || [];

        if (!(values instanceof Array)) {
            throw "values must be an array";
        }

        if (!(fn instanceof Function)) {
            throw "2nd argument for parEach needs to be a function";
        }

        var self = this;

        function addSequence(value) {

            var seqFn;

            if (fn.length >= 2) {
                // async
                seqFn = function (cb) {
                    fn(value, cb);
                };
            } else {
                // sync
                seqFn = function () {
                    return fn(value);
                };
            }

            self.seq(seqFn);

        }

        for (var i = 0; i < values.length; i++) {
           addSequence(values[i]);
        }

        return this;
    };


    Flow.prototype.exec = function (cb) {
        var self = this;

        var callback = function (err, data) {
            if (cb) {
                cb(err, data);
            }
        };

        function flowEnd(err, results) {
            try {
                callback(err, results);
            } catch (e) {
                // error in exec
                if (self.errorHandler) {
                    try {
                        self.errorHandler(e);
                    } catch (e) {
                        // error in errorHandler, catch silent
                    }
                }
            }
        }

        function execNext(index) {
            if (index < self.$context.actions.length) {
                // execute action
                self.$context.actions[index](function (err, end) {
                    if (err || end) {
                        flowEnd(err, self.$context.vars);
                    } else {
                        execNext(index + 1);
                    }
                });

            } else {
                flowEnd(null, self.$context.vars)
            }
        }

        execNext(0);

    };

    if (typeof console !== "undefined" && console) {
        var log = (console.warn || console.log);
        if (log instanceof Function) {
            Flow.prototype.errorHandler = function (e) {
                if (e instanceof Error) {
                    log.call(console, [e.message, e.stack]);
                } else {
                    log.call(console, e);
                }
            }
        }
    }

    // global on the server, window in the browser
    var previous_flow = exports.flow;

    flow.noConflict = function () {
        exports.flow = previous_flow;
        return flow;
    };

    exports.flow = flow;
    exports.Flow = Flow;

}(typeof(exports) === "undefined" ? this : exports));define('flow', function () { return flow; });
define("flow", function(){});

define('js/core/History',["js/core/Bindable", "flow"], function (Bindable, flow) {


    var routeStripper = /^#?!?\/?/,
        undef,
        emptyCallback = function () {
        };

    var History = Bindable.inherit("js.core.History", {

        ctor: function () {
            this.callBase();
            this.$routers = [];
            this.$processUrl = true;

            this.$history = [];
        },

        defaults: {
            interval: 50
        },

        // TODO: make this bindable so that i can call this.fragment.triggerChange()
        fragment: function() {
            return this.$fragment;
        },

        getFragment: function () {
            var fragment;

            if (this.runsInBrowser()) {
                fragment = decodeURIComponent(window.location.hash);
            } else {
                fragment = this.$history[this.$history.length - 1] || "";
            }

            return fragment.replace(routeStripper, '');
        },

        start: function (callback, initialHash) {

            var self = this;
            this.$checkUrlFn = function () {
                self.checkUrl.apply(self, arguments);
            };


            if (this.runsInBrowser()) {
                // we're on a browser
                if ("onhashchange" in window) {
                    if (window.addEventListener) {
                        window.addEventListener('hashchange',
                            this.$checkUrlFn, false);
                    } else {
                        window.attachEvent('onhashchange', this.$checkUrlFn);
                    }
                } else {
                    // polling
                    this.$checkUrlInterval = setInterval(this.$checkUrlFn, this.$.interval);
                }
            } else {
                // rendering on node
                this.$history.push(initialHash || "");
            }

            this.$fragment = this.getFragment();
            this.navigate(this.$fragment, true, true, callback);
            this.$processUrl = true;

        },

        stop: function () {
            if (typeof window !== "undefined") {
                if ("onhashchange" in window) {
                    if (window.removeEventListener) {
                        window.removeEventListener('hashchange',
                            this.$checkUrlFn, false);
                    } else {
                        window.detachEvent('onhashchange', this.$checkUrlFn);
                    }
                } else {
                    // polling
                    clearInterval(this.$checkUrlInterval);
                }
            }
        },

        addRouter: function (router) {
            this.$routers.push(router);
        },

        checkUrl: function (e) {

            if (this.$processUrl) {
                var currentFragment = this.getFragment();
                if (currentFragment == this.$fragment) {
                    return false;
                }

                this.navigate(currentFragment, true, true, emptyCallback);
            }

            this.$processUrl = true;

        },

        triggerRoute: function (fragment, callback) {

            var routeExecutionStack = [];

            for (var i = 0; i < this.$routers.length; i++) {
                routeExecutionStack = routeExecutionStack.concat(this.$routers[i].generateRoutingStack(fragment));
            }

            if (routeExecutionStack.length === 0) {
                console.log("no route for '" + fragment + "' found.");
                // no route found but
                if (callback) {
                    // execute callback
                    callback();
                }
            } else {
                flow()
                    .seqEach(routeExecutionStack, function(routingFunction, cb){
                        routingFunction(cb);
                    })
                    .exec(callback)
            }
        },

        navigate: function (fragment, createHistoryEntry, triggerRoute, callback) {

            var self = this;

            if (!callback && createHistoryEntry instanceof Function) {
                callback = createHistoryEntry;
                createHistoryEntry = null;
            }

            if (!callback && triggerRoute instanceof Function) {
                callback = triggerRoute;
                triggerRoute = null;
            }

            if (createHistoryEntry == undef || createHistoryEntry == null) {
                createHistoryEntry = true;
            }

            if (triggerRoute == undef || triggerRoute == null) {
                triggerRoute = true;
            }

            var eventData = {
                fragment: fragment,
                createHistoryEntry: createHistoryEntry,
                triggerRoute: triggerRoute
            };

            this.trigger(History.EVENTS.NAVIGATION_START, eventData);

            this.$processUrl = false;

            if (createHistoryEntry) {
                if (this.runsInBrowser()) {
                    window.location.hash = "/" + fragment;
                } else {
                    this.checkUrl(null);
                }
                this.$history.push(fragment);
            } else {
                if (this.runsInBrowser()) {
                    // replace hash
                    window.location.replace("#/" + fragment);
                }
                this.$history[this.$history.length - 1] = fragment;

            }

            this.$fragment = fragment;

            if (triggerRoute) {
                this.triggerRoute(fragment, function() {
                    self.trigger(History.EVENTS.NAVIGATION_COMPLETE, eventData);
                    callback.apply(arguments);
                });
            } else {
                this.trigger(History.EVENTS.NAVIGATION_COMPLETE, eventData);
            }
        }
    });

    History.EVENTS = {
        NAVIGATION_START: "navigationStart",
        NAVIGATION_COMPLETE: "navigationComplete"
    };

    return History;
});
define('js/core/Bus',['js/core/EventDispatcher'], function(EventDispatcher) {
    // no extra functionality needed, but we need a separate instance
    return EventDispatcher.inherit('js.core.Bus', {
    });
});
define('js/core/Application',["js/core/UIComponent", "js/core/History", "js/core/Bus"], function (UIComponent, History, Bus) {
        return UIComponent.inherit("js.core.Application", {
            $classAttributes: [/.+/],
            ctor: function () {
                this.history = new History();

                this.callBase();
            },

            initialize: function () {
                // set up application wide vars
                this.callBase();
            },

            _inject: function () {
                // overwrite and call inside start
            },

            _initializeDescriptors: function () {
                this.callBase();
                UIComponent.prototype._inject.call(this);
            },

            /**
             * Method called, when application is initialized
             *
             * @param {Object} parameter
             * @param {Function} callback
             */
            start: function (parameter, callback) {
                parameter = parameter || {};
                this.$systemManager.$parameter = parameter;
                this.startHistory(callback, parameter.initialHash);
            },

            startHistory: function(callback, initialHash) {
                this.history.start(callback, initialHash);
            },

            render: function (target) {
                var dom = this.callBase(null);

                if (target) {
                    target.appendChild(dom);
                }

                this.$systemManager.$bus.trigger('Application.Rendered');

                return dom;
            },
            toString: function () {
                return "js.core.Application";
            }
        });
    }
);
define('js/core/List',["js/core/Bindable", "underscore"], function (Bindable, _) {
    return Bindable.inherit("js.core.List", {
        ctor: function (items, attributes) {
            this.$items = [];

            this.callBase(attributes);

            if (items) {
                this.add(items);
            }

            var self = this;
            this.bind('add', function () {
                self.length = self.size();
            });
            this.bind('remove', function () {
                self.length = self.size();
            });

            this.length = this.size();
        },
        hasItems: function () {
            return this.$items.length > 0;
        }.on("add", "remove"),
        push: function (item) {
            // TODO: add options
            this.$items.push(item);
            this.trigger('add', {item: item, index: this.$items.length - 1});
        },
        pop: function () {
            // TODO: add options
            return this.removeAt(this.$items.length);
        },
        shift: function () {
            // TODO: add options
            return this.removeAt(0);
        },
        unshift: function (item) {
            // TODO: add options
            this.$items.unshift(item);
            this.trigger('add', {item: item, index: 0});
        },
        add: function (items, options) {


            options = options || {};
            _.defaults(options, {silent: false, index: this.$items.length});

            var index = options.index;

            if (!_.isArray(items)) {
                items = [items];
            }
            var item, itemIndex;
            for (var i = 0; i < items.length; i++) {
                item = items[i];
                if (item instanceof Bindable) {
                    item.bind('change', this._onItemChange, this);
                }
                itemIndex = index + i;
                this.$items.splice(itemIndex, 0, item);
                if (options.silent !== true) {
                    this.trigger('add', {item: item, index: itemIndex})
                }
            }
        },
        _onItemChange: function (e, item) {
            this.trigger('change', {item: item, index: this.$items.indexOf(item)});
        },
        remove: function (items, options) {

            if (!_.isArray(items)) {
                items = [items];
            }
            for (var i = 0; i < items.length; i++) {
                this.removeAt(this.$items.indexOf(items[i]), options);
            }
        },
        removeAt: function (index, options) {
            options = options || {};

            if (index > -1 && index < this.$items.length) {
                var items = this.$items.splice(index, 1);
                if (options.silent !== true) {
                    this.trigger('remove', {item: items[0], index: index});
                }
                return items[0];
            }
            return null;
        },
        reset: function (items) {
            this.$items = items;
            this.trigger('reset', {items: items});
        },
        sort: function (fnc) {
            this.trigger('sort', {items: this.$items.sort(fnc), sortFnc: fnc});
        },
        clear: function () {
            this.reset([]);
        },
        size: function () {
            return this.$items.length;
        }.on('add', 'remove'),
        at: function (index) {
            if (index < this.$items.length && index >= 0) {
                return this.$items[index];
            }
            return null;
        },
        each: function (fnc, scope) {
            scope = scope || this;
            for (var i = 0; i < this.$items.length; i++) {
                fnc.call(scope, this.$items[i], i);
            }
        }
    })
});
define('js/data/Entity',['require', 'js/core/Bindable', 'js/core/List'],
    function(require, Bindable, List) {
    var cid = 0,
        Collection;

    var Entity = Bindable.inherit('js.core.Entity', {

        ctor: function(attributes) {

            // generate unique id
            this.$cid = ++cid;


            this._extendSchema();

            this.callBase(attributes);
        },

        $schema: {},

        $context: null,

        $dependentObjectContext: null,

        $cacheInRootContext: false,

        $isDependentObject: true,

        _extendSchema: function () {
            var base = this.base;

            while (base instanceof Entity) {
                var baseSchema = base.$schema;
                for (var type in baseSchema) {
                    if (baseSchema.hasOwnProperty(type) && !this.$schema.hasOwnProperty(type)) {
                        this.$schema[type] = baseSchema[type];
                    }
                }
                base = base.base;
            }
        },

        getContextForChildren: function(childFactory) {

            if (childFactory.prototype.$cacheInRootContext) {
                return this.$context.$datasource.getContext();
            }

            // TODO: this is the circle dependency. check different than use model
            if (this._isChildFactoryDependentObject(childFactory)) {
                // dependent object, which should be cached in context of the current entity
                if (!this.$dependentObjectContext) {
                    // create a new non-cached context for dependent objects
                    this.$dependentObjectContext = this.$context.$datasource.createContext();
                }

                return this.$dependentObjectContext;
            }


            return this.$context;
        },

        _isChildFactoryDependentObject: function(childFactory) {
            return childFactory && childFactory.prototype.$isDependentObject;
        },

        /**
         * parse the deserializied data
         * @param data
         */
        parse: function (data, action, options) {

            if (!Collection) {
                try {
                    Collection = require('js/data/Collection');
                } catch (e) {
                    // because a circular dependency from Entity -> Collection and Collection -> Model -> Entity
                    // we require Collection here, and if Collection is specified as schema, we can use it here
                }
            }

            var processor = this.$context.$datasource.getProcessorForModel(this);
            data = processor.parse(data, action, options);

            var schema = this.$schema;

            // convert top level properties to Models respective to there schema
            for (var type in schema) {
                if (schema.hasOwnProperty(type)) {
                    if (data.hasOwnProperty(type)) {
                        // found key in data payload

                        var value = data[type],
                            schemaType = schema[type],
                            factory,
                            entity,
                            i,
                            list,
                            alias;

                        if (schemaType instanceof Array) {
                            if (schemaType.length === 1) {
                                factory = schemaType[0];
                            } else if (schemaType.length === 0) {
                                this.log('ModelFactory for ListItem for "' + type + '" not defined', 'warn');
                                factory = Entity;
                            } else {
                                throw "Cannot determinate ModelFactory. Multiple factories defined for '" + type + "'.";
                            }

                            if (!(factory.prototype instanceof Entity)) {
                                throw "Factory for type '" + type + "' isn't an instance of Entity";
                            }

                            if (value instanceof Array || value === null) {
                                list = data[type] = new List();

                                // set alias to type if generic entity
                                alias = (factory === this.$context.$datasource.$entityFactory ||
                                    factory === this.$context.$datasource.$modelFactory) ? type : null;

                                if (value) {
                                    for (i = 0; i < value.length; i++) {
                                        entity = this.getContextForChildren(factory).createEntity(factory, value[i].id, alias);
                                        entity.set(entity.parse(value[i], action, options));
                                        list.add(entity);
                                    }
                                }

                            } else {
                                throw 'Schema for type "' + type + '" requires to be an array';
                            }


                        } else if (Collection && schemaType.classof(Collection)) {

                            // set alias to type if generic collection
                            alias = (schemaType === this.$context.$datasource.$collectionFactory) ? type : schemaType.prototype.$alias;

                            var contextForChildren = this.getContextForChildren(schemaType);
                            list = data[type] = contextForChildren.createCollection(schemaType, null, alias);
                            list.set(value);

                            if (value instanceof Array || value === null) {

                                for (i = 0; i < value.length; i++) {
                                    // create new entity based on collection type
                                    entity = contextForChildren.createEntity(list.$modelFactory);
                                    entity.set(entity.parse(value[i], action, options));
                                    // and add it to the collection
                                    list.add(entity);
                                }
                            } else {
                                // TODO: what here
//                                throw 'Schema for type "' + type + '" requires to be an array';
                            }
                        }
                        else {
                            factory = schemaType || Entity;

                            if (!(factory.prototype instanceof Entity)) {
                                throw "Factory for type '" + type + "' isn't an instance of Entity";
                            }

                            // set alias to type if generic entity
                            alias = (factory === this.$context.$datasource.$entityFactory ||
                                factory === this.$context.$datasource.$modelFactory) ? type : null;

                            data[type] = entity = this.getContextForChildren(factory).createEntity(factory, this.$.id, alias);
                            entity.set(entity.parse(value, action, options));
                        }
                    }
                }
            }

            return data;
        },

        prepare: function(action, options) {
            return this.$;
        },

        /***
         * composes the data for serialisation
         * @param action
         * @param options
         * @return {Object} all data that should be serialized
         */
        compose: function (action, options) {
            return this.prepare(action, options);
        }

//        preCompose: function (data, action, options) {
//            var processor = this.$context.$datasource.getProcessorForModel(this);
//            return processor.preCompose(data, action, options);
//        },
//
//        postCompose: function (data, action, options) {
//            var processor = this.$context.$datasource.getProcessorForModel(this);
//            return processor.postCompose(data, action, options);
//        }

    });


    return Entity;

});
define('js/data/Model',["js/data/Entity", "js/core/List", "flow", "underscore"], function (Entity, List, flow, _) {

    var FETCHSTATE = {
        CREATED: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: -1
    };

    var STATE = {
        NEW: 0,
        CREATED: 1,
        DELETED: -1
    };

    var Model = Entity.inherit("js.data.Model", {
        ctor: function (attributes) {
            // set model class name
            this.$modelClassName = this.constructor.name;

            // stores the current fetch state
            this._fetch = {
                callbacks: [],
                state: FETCHSTATE.CREATED
            };

            this.callBase(attributes);
        },

        $isDependentObject: false,

        save: function (options, callback) {

            // TODO: handle multiple access
            try {
                var status = this._status();

                if (status === STATE.NEW || status === STATE.CREATED) {
                    this.$context.$datasource.saveModel(this, options, callback);
                } else {
                    throw "status '" + status + "' doesn't allow save";
                }
            } catch (e) {
                if (callback) {
                    callback(e);
                }
            }

        },


        prepare: function(attributes, action) {
            attributes = this.callBase();

            if (action === "create") {
                // remove id
                delete(attributes.id);
            }

            return attributes;

        },

        compose: function(action, options) {
            var data = this.callBase();

            var processor = this.$context.$datasource.getProcessorForModel(this, options);
            return processor.compose(data, action, options);
        },

        /**
         * @param options
         * @param options.fetchSubModels
         * @param {Function} callback - function(err, model, options)
         */
        fetch: function (options, callback) {
            options = options || {};

            var self = this;

            if (this._fetch.state === FETCHSTATE.LOADING) {
                // currently fetching -> register callback
                this._fetch.callbacks.push(function (err, model) {
                    modelFetchedComplete(err, model, options, callback);
                });
            } else if (this._fetch.state == FETCHSTATE.LOADED) {
                // completed loaded -> execute
                modelFetchedComplete(null, this, options, callback);
            } else {
                // set state and start loading
                self._fetch.state = FETCHSTATE.LOADING;

                this.$context.$datasource.loadModel(this, options, function (err, model) {
                    self._fetch.state = err ? FETCHSTATE.ERROR : FETCHSTATE.LOADED;

                    // execute callbacks
                    modelFetchedComplete(err, model, options, callback);

                    _.each(self._fetch.callbacks, function (cb) {
                        cb(err, model);
                    });

                });
            }
        },
        remove: function (options, callback) {
            // TODO: handle multiple access
            try {
                var status = this._status();
                var self = this;
                if (status === STATE.CREATED) {
                    this.$context.$datasource.removeModel(this, options, function(err){
                        if(!err){
                            self.set('id', false);
                        }
                        callback(err);
                    });
                } else {
                    throw "status '" + status + "' doesn't allow delete";
                }
            } catch(e) {
                if (callback) {
                    callback(e);
                }
            }
        },

        _status: function () {
            if (this.$.id === false) {
                return STATE.DELETED;
            } else {
                return this.$.id ? STATE.CREATED : STATE.NEW;
            }
        }.onChange('id')
    });

    function fetchSubModels(attributes, subModelTypes, delegates) {
        _.each(attributes, function (value) {
            if (value instanceof Model) {
                // check if the model is required
                var subModelTypeEntry = subModelTypes[value.$alias];

                if (subModelTypeEntry) {
                    // model required -> create delegate
                    subModelTypeEntry.found = true;

                    delegates.push(function (cb) {
                        value.fetch({
                            fetchSubModels: subModelTypeEntry.subModels
                        }, cb);
                    });
                }
            } else if (value instanceof Object) {
                fetchSubModels(value, subModelTypes, delegates);
            }
        });
    }

    function modelFetchedComplete(err, model, options, originalCallback) {

        var callback = function (err, model) {
            if (originalCallback) {
                originalCallback(err, model, options)
            }
        };

        if (err) {
            callback(err, model);
        } else {

            var delegates = [];

            if (options.fetchSubModels && options.fetchSubModels.length > 0) {

                // for example fetch an article with ["currency", "product/design", "product/productType"]
                var subModelTypes = Model.createSubModelLoadingChain(model, options.fetchSubModels);

                fetchSubModels(model.$, subModelTypes, delegates);

                // check that all subResources where found
                var missingSubModels = _.filter(subModelTypes, function (subModel) {
                    return !subModel.found;
                });

                if (missingSubModels.length > 0) {
                    // TODO load again with fullData=true if not laoded with fullData=false
                    console.log(["requested submodel missing", missingSubModels]);

                    callback("requested submodel missing", model);
                    return;
                }
            }

            // execute all delegates in parallel and then execute callback
            flow()
                .par(delegates)
                .exec(function (err) {
                    callback(err, model);
                });
        }
    }

    Model.createSubModelLoadingChain = function (model, subModels) {
        var ret = {},
            subModelParser = /^([\w][\w.]*)(?:\/([\w][\w.]*))?$/;

        _.each(subModels, function (item) {
            var parts = subModelParser.exec(item);
            if (parts) {
                var subModelType = parts[1];
                var subModelSubType = parts[2];

                var subModelTypeEntry = ret[subModelType];
                if (!subModelTypeEntry) {
                    // create an entry
                    subModelTypeEntry = {
                        type: subModelType,
                        found: false,
                        subModels: []
                    };
                }

                // add required subModelTypeStrings
                if (subModelSubType) {
                    subModelTypeEntry.subModels.push(subModelSubType);
                }
                ret[subModelType] = subModelTypeEntry;
            }
        });

        return ret;
    };

    Model.STATE = STATE;
    Model.FETCHSTATE = FETCHSTATE;

    return Model;
});
define('js/html/Input',["js/html/HtmlElement"], function (HtmlElement) {
        return HtmlElement.inherit("js.html.Input", {
            $classAttributes: ['updateOnEvent','checked'],
            defaults: {
                type: 'text',
                checked: false,
                updateOnEvent: 'keyup'
            },
            _renderValue: function (value) {
                if(value !== this.$el.value){
                    this.$el.value = value;
                }
            },
            _renderChecked: function (checked) {
                this.$el.checked = checked;
            },
            _bindDomEvents: function () {

                var self = this;
                if (this.$.type === "text" || this.$.type === "password") {
                    this.bindDomEvent(this.$.updateOnEvent, function (e) {
                        self.set('value', self.$el.value);
                    });
                } else if (this.$.type === "checkbox" || this.$.type === "radio") {
                    this.bindDomEvent('click', function (e) {
                        self.set('checked', self.$el.checked);
                    });
                } else if(this.$.type == "number" ){
                    this.bindDomEvent(this.$.updateOnEvent, function (e) {
                        var val = parseInt(self.$el.value);
                        if(isNaN(val)){
                            val = self.$.value;
                        }
                        self.set('value', val);
                    });
                }

                this.callBase();
            }
        });
    }
);
define('js/conf/Configuration',["js/core/Component"], function (Component) {
    return Component.inherit("js.core.Component", {
    });
});
define('js/conf/Route',["js/conf/Configuration"], function (Configuration) {
    return Configuration.inherit("js.conf.Route", {});
});
define('js/core/Router',["js/core/Component", "underscore", "js/conf/Route"],

    function (Component, _, Route) {

        return Component.inherit("js.core.Router", {
            ctor: function () {

                this.$routes = [];

                this.callBase();
            },

            initialize: function () {
                this.callBase();

                if (this.$.history) {
                    this.history = this.$.history;
                } else {
                    this.history = this.$systemManager.$application.history;
                }

                this.history.addRouter(this);
            },

            _initializeChildren: function (childComponents) {
                this.callBase();
            },

            _childrenInitialized: function () {
                this.callBase();

                for (var c = 0; c < this.$configurations.length; c++) {
                    var config = this.$configurations[c];

                    if (config instanceof Route) {
                        this.addRoute(config.$);
                    }
                }
            },


            /**
             *
             * @param {Regexp|Object} route
             * @param {Function} [fn]
             */
            addRoute: function () {

                var route;
                if (arguments.length == 2) {
                    route = {
                        route: arguments[0],
                        fn: arguments[1]
                    }
                } else {
                    route = arguments[0];
                }

                if (route.onexec) {
                    route.fn = this.$rootScope[route.onexec];
                }

                _.defaults(route, {
                    name: null,
                    route: null,
                    fn: null
                });

                if (route.route && !(route.route instanceof RegExp)) {
                    // build regex from string
                    route.route = new RegExp(route.route);
                }

                if (!(route.fn && route.route)) {
                    throw "fn and route required"
                }

                this.$routes.push(route);
            },

            generateRoutingStack: function(fragment) {

                var delegates = [],
                    rootScope = this.$rootScope,
                    self = this;

                function addDelegate(route, params) {

                    delegates.push(function(cb) {

                        var fragment = params.shift();
                        var routeContext = {
                            callback: cb,
                            router: self,
                            params: _.clone(params),
                            fragment: fragment,
                            // breaks the routeStack execution
                            end: function() {
                                cb.end();
                            },
                            navigate: function(fragment, createHistoryEntry, triggerRoute)  {
                                if (_.isUndefined(createHistoryEntry)) {
                                    createHistoryEntry = false;
                                }

                                self.navigate(fragment, createHistoryEntry, triggerRoute, cb);
                            }
                        };

                        params.unshift(routeContext);

                        if (route.fn._async) {
                            try {
                                route.fn.apply(rootScope, params);
                            } catch (e) {
                                cb(e);
                            }
                        } else {
                            // exec route sync, call callback after execution
                            try {
                                cb(null, route.fn.apply(rootScope, params));
                            } catch (e) {
                                cb(e);
                            }
                        }
                    });
                }

                for (var i = 0; i < this.$routes.length; i++) {
                    // get the route
                    var route = this.$routes[i];
                    // and test against regexp
                    var params = route.route.exec(fragment);

                    if (params) {
                        // route matches
                        addDelegate(route, params);
                    }
                }

                return delegates;
            },

            executeRoute: function (fragment, callback) {
                // Test routes and call callback
                for (var i = 0; i < this.$routes.length; i++) {
                    var route = this.$routes[i];
                    var params = route.route.exec(fragment);
                    if (params) {

                        var cb = function (err, data) {
                            if (callback) {
                                callback(err, data);
                            }
                        };

                        params.shift();

                        var routeContext = {
                            callback: cb,
                            router: this,
                            params: _.clone(params),
                            fragment: fragment
                        };

                        params.unshift(routeContext);

                        var thisArg = this.$rootScope;

                        if (route.fn._async) {
                            route.fn.apply(thisArg, params);
                        } else {
                            // exec route sync, call callback after execution
                            try {
                                cb(null, route.fn.apply(thisArg, params));
                            } catch (e) {
                                cb(e);
                            }
                        }

                        return true;
                    }
                }

                return false;
            },

            /**
             * shortcut to history.navigate
             * @param to
             * @param createHistoryEntry
             * @param triggerRoute
             */
            navigate: function (to, createHistoryEntry, triggerRoute, callback) {
                return this.history.navigate(to, createHistoryEntry, triggerRoute, callback);
            }
        });
    });
define('js/core/I18n',["require", "js/core/Component", "underscore"], function (require, Component, _) {
    return Component.inherit("js.core.I18n", {
        defaults: {
            path: 'app/locale',
            locale: null,
            suffix: '.json',
            translations: {}
        },

        initialize: function () {
            this.callBase();

            this.loadLocale(this.$.locale);
        },

        _commitChangedAttributes: function (attributes) {
            if (attributes.locale) {
                this.loadLocale(attributes.locale);
            }
        },

        loadLocale: function (locale, callback) {

            if (!locale) {
                throw "locale not defined";
            }

            var self = this;
//            if(callback){
//                callback();
//            }
            require(['json!' + this.$.path + '/' + this.$.locale], function (translations) {
                self.set({
                    translations: translations
                });

                if (callback) {
                    callback();
                }
            });
        },

        /**
         * @param [num] for plural or singular
         * @param key translation key
         * @param - replacement for %0
         * @param - replacement for %1 ...
         */
        translate: function () {

            var args = Array.prototype.slice.call(arguments);
            var key = args.shift(), isPlural;
            if (_.isNumber(key)) {
                isPlural = key !== 1;
                key = args.shift();
            }
            if (isPlural) {
                key += "_plural";
            }

            var value = this.$.translations[key] || "";

            for (var i = 0; i < args.length; i++) {
                // replace, placeholder
                value = value.split("%" + i).join(args[i]);
            }

            return value;
        }.onChange("translations")
    })
});
define('js/core/Script',["js/core/Element"], function (Element) {
    return Element.inherit("js.core.Script", {
        // all the crazy stuff is done in xaml.js
        evaluate: function (imports) {
            var textContent = this._getTextContentFromDescriptor(this.$descriptor);
            var fn = eval("this.javascript = (" + textContent + ")");
            return fn.apply(this, imports);
        }
    });
});
define('js/ui/View',["js/html/HtmlElement", "js/core/Content", "underscore"], function (HtmlElement, Content, _) {
        return HtmlElement.inherit({
            defaults: {
                tagName: "div"
            },
            render: function () {
                // look if the component has a layout defined
                var layout = this.$templates['layout'];
                // if layout template available...
                if (layout) {
                    var children = layout.createComponents({}, this, this);
                    this._initializeLayoutChildren(children);
                }
                return this.callBase();
            },
            _initializeLayoutChildren: function (children) {
                for (var i = 0; i < children.length; i++) {
                    children[i].$rootScope = this;
                    this.addChild(children[i]);
                }
            },
            _renderChild: function (child) {
                this.callBase();
                if (child instanceof Content) {
                    var ref = child.get('ref');
                    if (ref) {
                        var placeHolder = this.getPlaceHolder(ref);
                        if (placeHolder) {
                            placeHolder.set({content: child});
                        }
                    }
                }
            },
            _renderLayoutClass: function (layoutClass, oldLayoutClass) {
                _.each(this.$renderedChildren, function (child) {
                    if (oldLayoutClass) {
                        child.removeClass(oldLayoutClass);
                    }
                    if (layoutClass) {
                        child.addClass(layoutClass)
                    }
                });
            },
            _renderComponentClass: function (cls, oldCls) {
                if (oldCls) {
                    this.removeClass(oldCls);
                }
                if (cls) {
                    this.addClass(cls);
                }
            },
            _renderClass: function (className) {
                if (className) {
                    this.addClass(className);
                }

            },
            _renderTemplateToPlaceHolder: function (templateName, placeholderName, attributes) {
                this.$renderedPlaceholders = this.$renderedPlaceholders || {};
                var renderedComponent = this.$renderedPlaceholders[placeholderName];
                if (!renderedComponent) {
                    var template = this.getTemplate(templateName);
                    if (template) {
                        // TODO: maybe render all components returned
                        // or create special method createComponent
                        renderedComponent = template.createComponents(attributes)[0];
                        // renderedComponent._initialize();
                        var placeholder = this.getPlaceHolder(placeholderName);
                        if (placeholder) {
                            placeholder.set({content: renderedComponent});
                            this.$renderedPlaceholders[placeholderName] = renderedComponent;
                        } else {
                            // throw "No placeholder '"+placeholderName+"' found";
                        }

                    }
                } else {
                    renderedComponent.set(attributes);
                }

            },
            _renderId: function (id) {
                if (id) {
                    this.$el.setAttribute("id", id);
                }

            }
        });
    }
);
define('js/core/Template',["js/core/Component"], function (Component) {
    // this is because circular dependency

    return Component.inherit("js.core.Template", {

        _initializeDescriptors: function () {
            this._cleanUpDescriptor(this.$descriptor);
            this._childrenInitialized();
        },

        createComponents: function (attributes, parentScope, rootScope) {
            rootScope = rootScope || this.$rootScope;
            parentScope = parentScope || this.$parentScope;
            // foreach child Descriptor
            var components = this._getChildrenFromDescriptor(this.$descriptor, null, rootScope);

            for (var c = 0; c < components.length; c++) {
                components[c].$parentScope = parentScope;
                components[c].set(attributes);
                components[c]._initialize("auto", true);

            }

            return components
        }
    });
});
define('js/ui/ItemsView',["js/ui/View", "js/core/Template", "js/core/List", "underscore"], function (View, Template, List, _) {
        return View.inherit({
            defaults: {
                tagName: "div",
                items: null,
                itemKey: 'item',
                indexKey: 'index'
            },

            $classAttributes: [
                'itemKey', 'indexKey'
            ],

            hasItems: function () {
                if (this.$.items) {
                    return this.$.items.length;
                }
                return 0;
            }.on('items'),

            render: function () {
                if (!this.isRendered()) {
                    this.$renderedItems = [];
                }
                return this.callBase();
            },

            _renderItems: function (items, oldItems) {
                if (oldItems && oldItems instanceof List) {
                    oldItems.unbind('sort', this._onSort, this);
                    oldItems.unbind('reset', this._onReset, this);
                    oldItems.unbind('add', this._onItemAdd, this);
                    oldItems.unbind('remove', this._onItemRemove, this);

                }

                if (items instanceof List) {
                    items.bind('sort', this._onSort, this);
                    items.bind('reset', this._onReset, this);
                    items.bind('add', this._onItemAdd, this);
                    items.bind('remove', this._onItemRemove, this);
                    this._innerRenderItems(items.$items);
                } else if (_.isArray(items)) {
                    this._innerRenderItems(items);
                }
            },
            _onSort: function (e) {
                if (this.isRendered()) {
                    var item, c;
                    for (var i = 0; i < e.$.items.length; i++) {
                        item = e.$.items[i];
                        c = this.getComponentForItem(item);
                        this.$el.removeChild(c.$el);
                        this.$el.appendChild(c.$el);
                    }
                }
            },

            _onReset: function (e) {
                this._innerRenderItems(e.$.items);
            },

            _onItemAdd: function (e) {
                this._innerRenderItem(e.$.item, e.$.index);
            },

            _onItemRemove: function (e) {
                this._removeRenderedItem(e.$.item);
            },

            _innerRenderItems: function (items) {
                if (this.$renderedItems) {
                    var c;
                    for (var j = this.$renderedItems.length - 1; j >= 0; j--) {
                        c = this.$renderedItems[j];
                        this.removeChild(c.component);
                        c.component.destroy();
                    }
                }
                this.$renderedItems = [];
                for (var i = 0; i < items.length; i++) {
                    this._innerRenderItem(items[i], i);
                }

            },

            _createComponentForItem: function (item, i) {
                var attr = {};
                attr[this._getItemKey()] = item;
                attr[this._getIndexKey()] = i;
                var comp = this.$templates['item'].createComponents(attr)[0];

                // add to rendered item map
                this.$renderedItems.push({
                    item: item,
                    component: comp
                });
                return comp;
            },

            _innerRenderItem: function (item, i) {
                this.addChild(this._createComponentForItem(item, i));
            },

            _getItemKey: function () {
                return "$" + this.$.itemKey;
            },

            _getIndexKey: function () {
                return "$" + this.$.indexKey;
            },

            _removeRenderedItem: function (item) {
                var ri;
                for (var i = 0; i < this.$renderedItems.length; i++) {
                    ri = this.$renderedItems[i];
                    if (ri.item === item) {
                        this.removeChild(ri.component);
                        this.$renderedItems.splice(i, 1);
                        ri.component.destroy();
                        return;
                    }
                }
            },

            getComponentForItem: function (item) {
                var ri;
                for (var i = 0; i < this.$renderedItems.length; i++) {
                    ri = this.$renderedItems[i];
                    if (ri.item === item) {
                        return ri.component;
                    }
                }
                return null;
            }
        });
    }
);
define('js/core/Injection',["js/core/Component", "underscore"], function (Component, _) {


    function factoryInheritsFrom(factory, type) {
        return factory == type || factory.prototype instanceof type;
    }

    return Component.inherit("js.core.Injection", {
        ctor: function (attributes, descriptor, systemManager, parentScope, rootScope) {

            if (!systemManager.$injection) {
                this.callBase();
                this.$singletonInstanceCache = [];
                this.$factories = [];

                if (systemManager.$bus) {
                    // make the bus available for injection
                    this.$factories.push(systemManager.$bus);
                }

                systemManager.$injection = this;
            }

            return systemManager.$injection;

        },

        _childrenInitialized: function () {
            this.callBase();

            for (var c = 0; c < this.$configurations.length; c++) {
                var config = this.$configurations[c];

                // TODO: TEST type of configuration
                this.addFactory(config.$);

            }
        },

        getInstance: function (type) {
            // TODO: add class hierarchy distance check
            var instance;

            if (_.isString(type)) {
                // inject by key
                if (this.$singletonInstanceCache.hasOwnProperty(type)) {
                    return this.$singletonInstanceCache[type];
                }
            } else {
                // go to the singleton instance and look for requested instance
                for (var i = 0; i < this.$singletonInstanceCache.length; i++) {
                    instance = this.$singletonInstanceCache[i];

                    if (instance instanceof type) {
                        return instance;
                    }
                }

                // instance not found -> go thought the factories
                for (var f = 0; f < this.$factories.length; f++) {
                    var factory = this.$factories[f];

                    if (factoryInheritsFrom(factory.factory, type)) {
                        // create instance
                        instance = new factory.factory();

                        if (instance instanceof type) {
                            if (factory.singleton) {
                                this.addInstance(instance)
                            }

                            return instance;
                        }
                    }
                }
            }


            throw "requested injection type not found";
        },

        addChild: function (child) {
            this.callBase(child);

            this.addInstance(child);
        },

        addFactory: function (factory) {

            if (factory instanceof Function) {
                factory = {
                    factory: factory
                }
            }

            _.defaults(factory, {
                "type": null,
                "factory": null,
                "singleton": false
            });

            if (!factory.factory) {
                // get factory from class
                var fac = this.$systemManager.$applicationDomain.getDefinition(factory.type);
                if (!fac) {
                    throw "factory for type '" + factory.type + "' not found";
                }
                factory.factory = fac;
            }

            this.$factories.push(factory);
        },

        /***
         *
         * @param {String} [key] a unique key
         * @param instance
         */
        addInstance: function (key, instance) {
            if (arguments.length == 1) {
                instance = key;
                key = null;
            }

            if (instance instanceof Function) {
                throw "got a factory instead of an instance"
            }

            if (key) {
                this.$singletonInstanceCache[key] = instance;
            } else {
                this.$singletonInstanceCache.push(instance);
            }


        }
    });
});
define('js/ui/ContentPlaceHolder',["js/ui/View"], function (View) {
    return View.inherit(({

        $classAttributes: ["name"],

        _renderContent: function (content) {
            this._clearRenderedChildren();
            if (content) {
                this._renderChildren(content.getChildren());
            }
        }
    }));
});
define('js/ui/TextWrapper',["js/ui/View"], function (View) {

        var findPlaceholders = function (str) {
            var placeholders = [], p;
            var stack = [], c, indexPos = 0;
            for (var i = 0; i < str.length; i++) {
                c = str.charAt(i);

                if (c == "[" && stack.length === 0) {
                    p = {};
                    p["start"] = i;
                    stack.push(i);
                } else if (c == "|") {
                    indexPos = i;
                } else if (c == "]" && stack.length > 0 && indexPos > 0) {
                    p["index"] = parseInt(str.substring(indexPos + 1, i));
                    p["end"] = i;
                    p["text"] = str.substring(p.start + 1, indexPos);
                    placeholders.push(p);
                    stack.pop();
                }
            }

            return placeholders;
        };

        return View.inherit({
            defaults: {
                tagName: "span"
            },
            _getChildrenFromDescriptor: function (descriptor) {
                return [];
            },
            _renderChildren: function () {

            },
            _renderContentChildren: function () {

            },
            _renderString: function (string, oldString) {
                for(var k = 0; k < this.$el.childNodes.length; k++){
                    this.$el.removeChild(this.$el.childNodes[k]);
                }
                if (string) {
                    var placeholders = findPlaceholders(string);
                    var ph, start = -1;
                    for (var i = 0; i < placeholders.length; i++) {
                        ph = placeholders[i];

                        if (ph.start > start) {
                            this.$el.appendChild(this.$systemManager.$document.createTextNode(string.substring(start + 1, ph.start)));
                        }

                        start = ph.end;
                        if (!this.$viewMap) {
                            this.$viewMap = {};
                        }
                        var key = ph.index + ":" + i;
                        var childView = this.$viewMap[key];
                        if (!childView) {
                            childView = this._createComponentForNode(this.$descriptor.childNodes[ph.index]);
                            if (childView) {
                                childView.$parentScope = this.$parentScope;
                                childView.$rootScope = this.$rootScope;
                                this.$viewMap[key] = childView;
                            }
                        }
                        if (childView) {
                            childView.set("$text", ph.text);
                            childView._initialize("auto", true);
                            if (!childView.isRendered()) {
                                childView.render();
                            }
                            this.$children.push(childView);
                            this.$el.appendChild(childView.$el);
                        } else {
                            this.$el.appendChild(this.$systemManager.$document.createTextNode(ph.text));
                        }
                    }
                    if (start < string.length) {
                        this.$el.appendChild(this.$systemManager.$document.createTextNode(string.substr(start + 1)));
                    }

                }
            }
        });
    }
);
/***
 *
 * Acts as base class for
 *
 * @class js.data.ListView
 */
define('js/data/DataView',["js/core/Component", "js/core/List" ,"underscore"], function (Component, List ,_) {

    return Component.inherit("js.data.DataView", {

        defaults: {
            filterFnc: function (item, index, list) {
                return true;
            }
        },
        initialize: function(){
            this.$.list = new List();
            this.bind('baseList','add', this._onItemAdded, this);
            this.bind('baseList','remove', this._onItemRemoved, this);
            this.bind('baseList','change', this._onItemChanged, this);
            this.bind('baseList','reset', this._onReset, this);
            this.bind('baseList','sort', this._onSort, this);

            if (this.$.baseList && this.$.baseList instanceof List) {
                this._innerReset(this.$.baseList.$items);
            }
        },
        _onItemChanged: function () {
            // implement
        },
        _onReset: function (e) {
            this._innerReset(e.items);
        },
        _onSort: function (e) {
            this.$.list.sort(e.sortFnc);
        },
        _innerReset: function (items) {
            // implement
        },
        destroy: function(){
            this.unbind('baseList', 'add', this._onItemAdded, this);
            this.unbind('baseList', 'remove', this._onItemRemoved, this);
            this.unbind('baseList', 'change', this._onItemChanged, this);
            this.unbind('baseList', 'reset', this._onReset, this);
            this.unbind('baseList', 'sort', this._onSort, this);

            this.callBase();
        }
    })
});
/***
 *
 * Filters items inside a list
 *
 * @class js.data.ListView
 */
define('js/data/FilterDataView',["js/data/DataView"], function (DataView) {

    return DataView.inherit("js.data.FilterListView", {
        initialize: function(){
            this.callBase();
            this.bind('change:filter', this._onFilterChanged, this);
            this.bind('filterFnc', this._onFilterChanged, this);
        },
        _onFilterChanged: function(){
            this._innerReset(this.$.baseList.$items);
        },
        _onItemAdded: function (e) {
            var ret = this._filterItem(e.$.item, e.index);
            if (ret === true) {
                this.$.list.add(e.$.item, e.index);
            }
        },
        _onItemRemoved: function (e) {
            this.$.list.remove(e.$.item, e.$.index);
        },
        _onItemChanged: function (e) {
            var keep = this._filterItem(e.$.item, e.$.index);
            var included = _.include(this.$.list.$items, e.$.item);
            if (included && keep === false) {
                this.$.list.remove(e.$.item, e.$.index);
            } else if (!included && keep === true) {
                this.$.list.add(e.$.item, e.$.index);
            }
        },
        _innerReset: function(items){
            var filtered = [], item;
            for (var i = 0; i < items.length; i++) {
                item = items[i];
                if (this._filterItem(item, i) === true) {
                    filtered.push(item);
                }
            }
            this.$.list.reset(filtered);
        },
        _filterItem: function (item, index) {
            if(this.$.filterFnc){
                return this.$.filterFnc.call(this, item, index, this.$.list);
            }
            return true;
        }
    });
});
define('js/data/Collection',['require', "js/core/List", "js/data/Model", "flow", "underscore"], function (require, List, Model, flow, _) {

    var cid = 0;

    var State = {
        CREATED: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: -1
    };

    var Collection = List.inherit("js.data.Collection", {

        $modelFactory: Model,

        ctor: function (items, options) {

            options = options || {};

            this.callBase(items);
            this.$cid = ++cid;

            _.defaults(options, {
                rootCollection: null,
                pageSize: null,
                queryParameters: {},
                factory: this.$modelFactory || require('js/data/Model'),
                type: null
            });

            this.$itemsCount = null;
            this.$queryCollectionsCache = {};
            this.$pageCache = [];
            this.$options = options;
        },

        getRootCollection: function () {
            return this.$options.rootCollection ? this.$options.rootCollection : this;
        },

        createQueryCacheKey: function (queryParameters) {
            queryParameters = queryParameters || {};
            var ret = [];

            for (var key in queryParameters) {
                if (queryParameters.hasOwnProperty(key)) {
                    ret.push(key + "=" + queryParameters[key]);
                }
            }

            ret.sort();

            if (ret.length == 0) {
                return "root";
            }

            return ret.join("&");
        },

        createQueryCollection: function (queryParameter) {

            var options = {
                queryParameter: queryParameter,
                rootCollection: this.getRootCollection()
            };

            // different queryParameter, same options
            _.defaults(options, this.$options);

            return new Collection(null, options);
        },

        // fetches the complete list
        fetch: function (options, callback) {
            options = options || {};

            var self = this;

            function fetchPages(pageCount) {
                var delegates = [];

                function addFetchPageDelegate(pageIndex) {
                    delegates.push(function (cb) {
                        self.fetchPage(pageIndex, options, cb);
                    });
                }

                for (var i = 0; i < pageCount; i++) {
                    addFetchPageDelegate(i);
                }

                // execute loading parallel
                flow()
                    .par(delegates)
                    .exec(function (err) {
                        if (callback) {
                            callback(err, self);
                        }
                    });
            }

            if (!this.$options.pageSize) {
                // unlimited pageSize -> create one and only page and fetch
                this.fetchPage(0, options, callback);
            } else {
                // determinate pages
                var pageCount = this.pageCount();

                if (!isNaN(pageCount)) {
                    // we know how many page are there
                    fetchPages(pageCount);
                } else {
                    // load first page in order to get the available itemCount
                    // to calculate the pageCount
                    this.fetchPage(0, options, function (err) {
                        if (!err) {
                            // we now should calculate a page count
                            pageCount = self.pageCount();

                            if (isNaN(pageCount)) {
                                if (callback) {
                                    callback("Count for collection couldn't be fetched.", self);
                                }
                            } else {
                                fetchPages(pageCount);
                            }
                        } else {
                            if (callback) {
                                callback(err, self);
                            }
                        }
                    })
                }
            }

        },

        pageCount: function () {
            if (this.$itemsCount) {
                return Math.ceil(this.$itemsCount / this.$options.pageSize);
            } else {
                // we actually don't know how many pages there will be
                return NaN;
            }
        },

        getContextForChildren: function(childFactory) {
            if (childFactory.prototype.$cacheInRootContext) {
                return this.$context.$datasource.getContext();
            }

            return this.$context;
        },

        parse: function(data, type) {
            if (!(data instanceof Array)) {
                throw "data has to be an array";
            }

            var factory = this.$modelFactory;
            var alias = (factory === this.$context.$datasource.$entityFactory ||
                factory === this.$context.$datasource.$modelFactory) ? type : this.$alias;

            for (var i = 0; i < data.length; i++) {
                var value = data[i];
                var entity = this.getContextForChildren(factory).createEntity(factory, value.id, alias, type);
                entity.set(entity.parse(value));

                data[i] = entity;
            }

            return data;
        },

        createItem: function(id, type) {
            return this.getContextForChildren(this.$modelFactory).createEntity(this.$modelFactory, id, type);
        },

        fetchPage: function (pageIndex, options, callback) {

            if (pageIndex < 0) {
                throw "pageIndex must be >= 0";
            }

            var page = this.$pageCache[pageIndex];
            if (!page) {
                page = this.$pageCache[pageIndex] = new Page(null, this.getRootCollection(), pageIndex);
            }

            var self = this;
            page.fetch(options, function (err, page) {

                // insert data into items if not already inserted
                if (!err && !page.itemsInsertedIntoCollection) {
                    page.itemsInsertedIntoCollection = true;

                    // add items to collection
                    self.add(page.$items, {
                        index: (pageIndex || 0) * self.$options.pageSize
                    });
                }

                if (callback) {
                    callback(err, page, options);
                }
            });
        },

        // returns a new collections
        find: function (parameters) {
            var queryKey = this.createQueryCacheKey(parameters);

            if (!this.$queryCollectionsCache.hasOwnProperty(queryKey)) {
                this.$queryCollectionsCache[queryKey] = this.createQueryCollection(parameters);
            }

            return this.$queryCollectionsCache[queryKey];
        }

    });

    var Page = Collection.Page = List.inherit({

        ctor: function (items, collection, pageIndex) {
            if (!collection.$options.pageSize && pageIndex !== 0) {
                throw "Cannot create page for index '" + pageIndex + "' with pageSize '" + collection.options.pageSize + "'";
            }

            var options = collection.$options;

            if (options.pageSize) {
                this.$offset = pageIndex * options.pageSize;
                this.$limit = options.pageSize;
            }

            this.$pageIndex = pageIndex;
            this.$collection = collection;

            this.callBase(items);

            // stores the current fetch state
            this._fetch = {
                callbacks: [],
                state: State.CREATED
            };

        },


        parse: function (data, type) {
            return this.$collection.parse.call(this.$collection, data, type);
        },

        /***
         *
         * @param options
         * @param [Boolean] [options.fetchModels=false] fetch models inside collection
         * @param [Array] [options.fetchSubModels] fetch sub models
         * @param callback
         */
        fetch: function (options, callback) {
            options = options || {};

            var self = this;

            function pageFetchedComplete(err, page, originalCallback) {
                var callback = function (err, page) {
                    if (originalCallback) {
                        originalCallback(err, page, options)
                    }
                };


                if (options.fetchModels || options.fetchSubModels) {

                    // TODO: introduce poolSize parameter for par, and parEach

                    flow()
                        .parEach(page.$items, function(model, cb) {
                            model.fetch({
                                fetchSubModels: options.fetchSubModels
                            }, cb);
                        })
                        .exec(function (err) {
                            callback(err, page);
                        });

                } else {
                    callback(err, page);
                }

            }

            if (this._fetch.state === State.LOADING) {
                // currently fetching -> register callback
                this._fetch.callbacks.push(function (err, page) {
                    pageFetchedComplete(err, page, callback);
                });
            } else if (this._fetch.state == State.LOADED) {
                // completed loaded -> execute
                pageFetchedComplete(null, this, callback);
            } else {
                // set state and start loading
                self._fetch.state = State.LOADING;

                this.$collection.$context.$datasource.loadCollectionPage(this, options, function (err, page) {
                    self._fetch.state = err ? State.ERROR : State.LOADED;

                    // execute callbacks
                    pageFetchedComplete(err, page, callback);

                    _.each(self._fetch.callbacks, function (cb) {
                        cb(err, page);
                    });
                });
            }
        }
    });

    Collection.of = function(modelFactory) {

        if (modelFactory instanceof Function) {
            return Collection.inherit(Collection.prototype.constructor.name + '[' + modelFactory.prototype.constructor.name + ']', {
                $modelFactory: modelFactory
            });
        } else if (_.isString(modelFactory)) {
            return Collection.inherit(Collection.prototype.constructor.name + '[' + modelFactory + ']', {
                $alias: modelFactory,
                $modelFactory: Model || require('js/data/Model')
            });
        } else {
            throw "Cannot create Collection of '" + modelFactory + "'.";
        }


    };

    return Collection;
});
define('js/data/DataSource',["require", "js/core/Component", "js/core/Base", "js/data/Collection", "underscore", "js/data/Model", "js/data/Entity", "js/core/List", "flow", "JSON"],
    function (require, Component, Base, Collection, _, Model, Entity, List, flow, JSON) {

        var undefined,
            Context = Base.inherit("js.data.DataSource.Context", {

                defaults: {
                    collectionPageSize: null
                },

                ctor: function (dataSource, properties, parentContext) {
                    this.callBase();

                    this.$datasource = dataSource;
                    this.$properties = properties;
                    this.$parent = parentContext;
                    this.$cache = {};

                },

                addEntityToCache: function (model) {
                    this.$cache[Context.generateCacheIdFromEntity(model)] = model;
                },

                addCollectionToCache: function (collection) {
                    this.$cache[Context.generateCacheIdFromCollection(collection)] = collection;
                },

                getInstanceByCacheId: function (cacheId) {
                    return this.$cache[cacheId];
                },

                getPathComponents: function () {
                    return [];
                },

                createEntity: function (factory, id, alias) {

                    if (_.isFunction(factory)) {

                        var entityClassName = factory.prototype.constructor.name;
                        alias = alias || (factory.classof(Model) ? this.$datasource.getAliasForModelClassName(entityClassName) : entityClassName);

                        if (factory.classof(Model) && !alias) {
                            throw "Alias for '" + entityClassName + "' not found";
                        }

                        var cachedItem;

                        // only get from cache if we got an id
                        if (id) {
                            cachedItem = this.getInstanceByCacheId(Context.generateCacheIdForEntity(alias, id));
                        }

                        if (!cachedItem) {
                            // create new Entity
                            cachedItem = new factory({
                                id: id
                            });
                            // set context
                            cachedItem.$context = this;
                            cachedItem.$alias = alias;

                            // and add it to the cache
                            this.addEntityToCache(cachedItem);
                        }

                        return cachedItem;

                    } else {
                        throw "Factory has to be a function";
                    }
                },

                createCollection: function (factory, options, alias) {
                    options = options || {};

                    if (_.isFunction(factory)) {

                        var collectionClassName = factory.prototype.constructor.name;
                        alias = alias || this.$datasource.getAliasForCollectionClassName(collectionClassName);

                        if (!alias) {
                            throw "Alias for '" + collectionClassName + "' not found";
                        }

                        _.defaults(options, {
                            factory: factory,
                            type: alias
                        });

                        var cachedCollection = this.getInstanceByCacheId(Context.generateCacheIdForCollection(alias));

                        if (!cachedCollection) {
                            // create new Collection
                            cachedCollection = new factory(null, options);
                            // set context
                            cachedCollection.$context = this;
                            cachedCollection.$alias = alias;

                            // and add it to the cache
                            this.addCollectionToCache(cachedCollection);
                        }

                        return cachedCollection;

                    } else {
                        throw "Factory has to be a function";
                    }
                }
            });

        Context.generateCacheIdForCollection = function (type) {
            return type;
        };

        Context.generateCacheIdForEntity = function (type, id) {
            return type + "_" + id;
        };

        Context.generateCacheIdFromEntity = function (entity) {
            return Context.generateCacheIdForEntity(entity.$alias, entity.$.id);
        };

        Context.generateCacheIdFromCollection = function (collection) {
            return Context.generateCacheIdForCollection(collection.$alias);
        };

        var Processor = Base.inherit("js.data.DataSource.Processor", {

            ctor: function (dataSource) {
                if (!dataSource) {
                    throw "dataSource is required for Processor";
                }

                this.$datasource = dataSource;
            },

            /***
             * prepares the data for being serialized
             * @param {JSON} data
             * @param {js.data.DataSource.ACTION} action
             * @return {JSON}
             */
            compose: function (data, action, options) {
                return this._composeObject(data, action, options);
            },

            _composeObject: function (obj, action, options) {

                var ret = {};

                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        var value = this._getCompositionValue(obj[key], action, options);

                        if (value !== undefined) {
                            ret[key] = value;
                        }
                    }
                }

                return ret;
            },

            _getCompositionValue: function (value, action, options) {
                if (value instanceof Model) {
                    return this._composeSubModel(value, action, options);
                } else if (value instanceof Collection) {
                    return this._composeCollection(value, action, options);
                } else if (value instanceof Entity) {
                    return value.compose(action, options);
                } else if (value instanceof List) {
                    var ret = [];
                    var self = this;
                    value.each(function (v) {
                        ret.push(self._getCompositionValue(v, action, options));
                    });
                    return ret;
                } else if (value instanceof Object) {
                    return this._composeObject(value);
                }
                else {
                    return value;
                }
            },

            _composeSubModel: function (model, action, options) {
                return model.compose(action, options);
            },

            _composeCollection: function (collection, action, options) {
                return undefined;
            },

            parse: function (data, action, options) {
                return data;
            },

            /***
             * saves sub models
             */
            saveSubModels: function (model, options, callback) {
                // TODO: handle circular dependencies

//                flow()
//                    .parEach(this.getSubModelsForModel(model), function(model, cb) {
//                        model.save(options, cb);
//                    })
//                    .exec(callback);

                // TODO: uncomment
                callback();
            },

            getSubModelsForModel: function (model) {

                var ret = [];

                function getSubModel(obj) {

                    if (obj === model) {
                        return;
                    }

                    if (_.indexOf(ret, obj) !== -1) {
                        // already in list
                        return;
                    }

                    if (obj instanceof Model) {
                        ret.push(obj);
                        return;
                    }

                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            var value = obj[key];

                            if (value instanceof Array) {
                                for (var i = 0; i < value.length; i++) {
                                    getSubModel(value[i]);
                                }
                            } else if (value instanceof List) {
                                value.each(function (v) {
                                    getSubModel(v);
                                });
                            } else if (value instanceof Object) {
                                getSubModel(value);
                            }
                        }
                    }
                }

                getSubModel(model.$);

                return ret;

            }
        });

        var DataSource = Component.inherit('js.data.DataSource', {

            ctor: function () {

                this.$configuredTypes = [];
                this.$contextCache = {};
                this.$formatProcessors = [];

                this.callBase();

                this.initializeFormatProcessors();
                this.initializeProcessors();

            },

            $processors: {},
            $modelFactory: Model,
            $entityFactory: Entity,
            $collectionFactory: Collection,
            $defaultProcessorFactory: Processor,
            $defaultProcessor: null,

            initializeFormatProcessors: function () {
                // hook
            },

            initializeProcessors: function () {
                this.$defaultProcessor = new this.$defaultProcessorFactory(this);

                for (var key in this.$processors) {
                    if (this.$processors.hasOwnProperty(key) && this.$processors[key] instanceof Function) {
                        // Factory instead of instance, create processor instance
                        this.$processors[key] = new (this.$processors[key])(this);
                    }
                }
            },

            _childrenInitialized: function () {
                this.callBase();

                for (var c = 0; c < this.$configurations.length; c++) {
                    var config = this.$configurations[c];
                    this.addTypeConfiguration(config);

                }
            },

            getAliasForModelClassName: function (modelClassName) {

                for (var i = 0; i < this.$configuredTypes.length; i++) {
                    var config = this.$configuredTypes[i];
                    if (config.$.modelClassName === modelClassName) {
                        return config.$.alias;
                    }
                }

                return null;
            },

            getAliasForCollectionClassName: function (collectionClassName) {
                for (var i = 0; i < this.$configuredTypes.length; i++) {
                    var config = this.$configuredTypes[i];
                    if (config.$.collectionClassName === collectionClassName) {
                        return config.$.alias;
                    }
                }

                return null;
            },


            addTypeConfiguration: function (configuration) {

                if (!configuration.$.modelClassName && !configuration.$.alias) {
                    throw "neither modelClassName nor alias defined";
                }

                if (configuration.$.modelClassName && !configuration.$.alias) {
                    configuration.$.alias = configuration.$.modelClassName.split(".").pop();
                }

                if (!configuration.$.modelClassName) {
                    configuration.$.modelClassName = "js.data.Model";
                }

                this.$configuredTypes.push(configuration);
            },

            getFqClassName: function (alias) {

                for (var i = 0; i < this.$configuredTypes.length; i++) {
                    var typeConfig = this.$configuredTypes[i];

                    if (typeConfig.$.alias == alias) {
                        return typeConfig.$.modelClassName;
                    }
                }
            },

            getContext: function (properties, parentContext) {

                var cacheId = this.createContextCacheId(properties, parentContext ? parentContext.$properties : null);

                if (!this.$contextCache.hasOwnProperty(cacheId)) {
                    this.$contextCache[cacheId] = this.createContext(properties, parentContext);
                }

                return this.$contextCache[cacheId];
            },

            /**
             * returns the root context
             */
            root: function () {
                return this.getContext();
            },

            createContext: function (properties, parentContext) {
                return new Context(this, properties, parentContext)
            },

            createContextCacheId: function (properties, parentProperties) {
                var ret = [];
                _.each(_.extend({}, parentProperties, properties), function (value, key) {
                    ret.push(key + "=" + value);
                });

                ret.sort();

                if (ret.length == 0) {
                    return "root";
                }

                return ret.join("&");
            },

            createEntity: function (factory, id, type, context) {
                context = context || this.getContext();

                return context.createEntity(factory, id, type);
            },

            createCollection: function (factory, options, type, context) {
                context = context || this.getContext();

                return context.createCollection(factory, options, type);
            },

            /**
             * resolve references to models and collections
             * @param {js.data.Model} model
             * @param {JSON} data deserialized, parsed data
             * @param {Object} options
             * @param {Function} callback - function (err, resolvedData)
             */
            resolveReferences: function (model, data, options, callback) {
                if (callback) {
                    callback("Abstract method", data);
                }
            },

            loadModel: function (model, options, callback) {
                if (callback) {
                    callback("Abstract method", model);
                }
            },

            /***
             *
             * @param list
             * @param options
             * @param callback
             */
            loadCollectionPage: function (list, options, callback) {
                if (callback) {
                    callback("Abstact method loadCollectionPage", list);
                }
            },

            saveModel: function (model, options, callback) {
                if (callback) {
                    callback("Abstract method saveModel", model);
                }
            },
            removeModel: function (model, options, callback) {
                if (callback) {
                    callback("Abstract method removeModel", model);
                }
            },

            /***
             * returns the configuration entry for the model class
             * @param modelClassName
             * @return {Configuration} configuration matching the model class name
             */
            getConfigurationForModelClass: function (modelClassName) {

                // TODO: cache
                for (var i = 0; i < this.$configuredTypes.length; i++) {
                    var config = this.$configuredTypes[i];
                    if (config.$.modelClassName === modelClassName) {
                        return config;
                    }
                }

                return null;
            },

            /***
             *
             * returns a configuration entry by matching the alias
             *
             * @param alias
             * @return {*}
             */
            getConfigurationByAlias: function (alias) {

                // TODO: cache it
                for (var i = 0; i < this.$configuredTypes.length; i++) {
                    var config = this.$configuredTypes[i];
                    if (config.$.alias === alias) {
                        return config;
                    }
                }

                return null;
            },

            getProcessorForModel: function (model, options) {

                if (model) {
                    var config;
                    if (model.constructor === this.$modelFactory) {
                        // default model -> working with alias
                        config = this.getConfigurationByAlias(model.$alias);
                    } else {
                        config = this.getConfigurationForModelClass(model.$modelClassName);
                    }

                    if (config && config.$.processor) {
                        var processorName = config.$.processor;
                        if (this.$processors[processorName]) {
                            return this.$processors[processorName];
                        } else {
                            throw "Processor for '" + processorName + "' not an instance of js.data.DataSource.Processor."
                        }
                    }
                }

                return this.$defaultProcessor;
            },

            getFormatProcessor: function (action) {
                return this.$formatProcessors[0];
            },

            update: function (data, callback) {
            },

            find: function (data, callback) {
            }
        });


        DataSource.FormatProcessor = Base.inherit("js.data.DataSource.FormatProcessor", {
            serialize: function (data) {
                throw "abstract method";
            },
            deserialize: function (responses) {
                throw "abstract method";
            }
        });

        DataSource.JsonFormatProcessor = DataSource.FormatProcessor.inherit("js.data.DataSource.JsonFormatProcessor", {
            serialize: function (data) {
                return JSON.stringify(data);
            },
            deserialize: function (text) {
                return JSON.parse(text);
            }
        });

        DataSource.Context = Context;

        DataSource.Processor = Processor;

        DataSource.ACTION = {
            LOAD: 'load',
            CREATE: 'create',
            UPDATE: 'update',
            DELETE: 'delete'
        };

        DataSource.IdGenerator = {
            genId: (function (uuidRegEx, uuidReplacer) {
                return function () {
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
                };
            })(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c == "x" ? r : (r & 3 | 8);
                return v.toString(16);
            })
        };

        return DataSource;
    });
define('js/data/LocalStorageDataSource',["js/data/DataSource", "js/data/Model", "flow"],
    function (DataSource, Model, flow) {

        var jsonFormatProcessor = new DataSource.JsonFormatProcessor();

        return DataSource.inherit("js.data.LocalStorageDataSource", {
            defaults : {
                name: 'default'
            },
            ctor: function() {
                this.callBase();

                this.$storage = this._getStorage();

                if (!this.$storage) {
                    throw "Storage not available";
                }
                var value = this.$storage.getItem(this.$.name);
                this.$data = (value && this.getFormatProcessor(null).deserialize(value)) || {};
            },
            getFormatProcessor: function(action){
                return jsonFormatProcessor;
            },
            getPathComponentsForModel: function (model) {
                if (model) {
                    var conf = this.getConfigurationByAlias(model.$alias);
                    if (conf) {
                        return [conf.$.path];
                    }
                }
                return null;
            },

            getPathForAlias: function (alias) {

                var typeConfig,
                    i;

                // search via alias
                for (i = 0; i < this.$configuredTypes.length; i++) {
                    typeConfig = this.$configuredTypes[i];
                    if (typeConfig.$.alias == alias) {
                        return typeConfig.$.path;
                    }
                }

                return null;
            },

            _getStorage: function() {
                if (typeof window !== "undefined" && window.localStorage) {
                    return window.localStorage;
                }

                return null;
            },
            _getCollectionData : function(path, contextPath){
                if (!path) {
                    callback("path for model unknown", null, options);
                    return;
                }

                // build uri
                var uri = [];
                if(contextPath){
                    uri = uri.concat(contextPath);
                }
                uri = uri.concat(path);

                return this.$data[uri.join(":")] || {};
            },
            loadCollectionPage: function (page, options, callback) {
                callback = callback || function(){};

                var path = page.$collection.$options.path ?
                    page.$collection.$options.path : this.getPathForAlias(page.$collection.$alias);

                var contextPath = page.$collection.$context.getPathComponents();



                var data = [], collection = this._getCollectionData(path, contextPath);
                for (var key in collection) {
                    if(collection.hasOwnProperty(key)){
                        data.push(this.$data[key]);
                    }
                }

                data = page.parse(data);
                page.add(data);


                callback(null, page, options);
            },
            saveModel: function (model, options, callback) {

                callback = callback || function(){
                };


                var action = DataSource.ACTION.UPDATE;

                if (model._status() === Model.STATE.NEW) {
                    action = DataSource.ACTION.CREATE;
                }

                var processor = this.getProcessorForModel(model, options);
                var formatProcessor = this.getFormatProcessor(action);
                var self = this;

                // call save of the processor to save submodels
                flow()
                    .seq(function (cb) {
                        processor.saveSubModels(model, options, cb)
                    })
                    .seq(function (cb) {
                        // compose data in model and in processor
                        var payload = model.compose(action, options);
                        if (model._status() === Model.STATE.NEW) {
                            payload.id = DataSource.IdGenerator.genId();
                        }
                        self.$data[payload.id] = payload;

                        // add
                        if(action === DataSource.ACTION.CREATE){
                            // get collection url for url
                            var modelPathComponents = self.getPathComponentsForModel(model);

                            if (!modelPathComponents) {
                                cb("path for model unknown");
                                return;
                            }

                            // build uri
                            var uri = [];
                            uri = uri.concat(model.$context.getPathComponents());
                            uri = uri.concat(modelPathComponents);

                            var collection = self.$data[uri.join(":")] || {};
                            collection[payload.id] = true;
                            self.$data[uri.join(":")] = collection;
                        }

                        self._saveStorage();
                        model.set('id',payload.id);
                        cb();
                    })
                    .exec(function (err) {
                        callback(err, model, options);
                    })


            },
            loadModel: function(model, options, callback){
                callback = callback || function(){};

                var formatProcessor = this.getFormatProcessor(DataSource.ACTION.LOAD);

                var payload;
                if (model.$.id) {
                    payload = this.$data[model.$.id];
                } else {
                    callback("Model has no id");
                    return;
                }

                if(!payload){
                    callback("Could not find model");
                    return;
                }

                payload = model.parse(payload);

                // TODO: resolve references
                model.set(payload);

                callback(null, model, options);
            },
            removeModel: function(model, options, callback){
                callback = callback || function () {
                };

                var payload;
                if (model.$.id) {
                    delete this.$data[model.$.id];

                    var collection = this._getCollectionData(this.getPathComponentsForModel(model));
                    if(collection){
                        delete collection[model.$.id];
                    }
                } else {
                    callback("Model has no id");
                    return;
                }
                this._saveStorage();

                callback(null, model, options);
            },

            _saveStorage: function(){
                this.$storage.setItem(this.$.name,this.getFormatProcessor(null).serialize(this.$data));
            }

        });
    });
define('js/html/a',['js/html/HtmlElement'], function (HtmlElement) {

    var externalLink = /^(([^:]+:\/\/)|(javascript:))/i,
        startsWithHash = /^#/,
        hashBankUrl = /^#?(.*)$/;

    return HtmlElement.inherit("js.html.a", {
        defaults: {
            tagName: 'a',
            target: null,
            href: null
        },
        _renderHref: function (href) {
            href = href || "javascript:void(0);";

            if (!(this.$.target === "external" || externalLink.test(href) || this.$.target === "_blank")) {
                // ajax link
                if (!startsWithHash.test(href)) {
                    href = "#" + href;
                }

                if (!this.runsInBrowser()) {
                    // node rendering -> hash bang url
                    href = href.replace(hashBankUrl, "#!$1");
                }
            }

            this.$el.setAttribute("href", href);
        },

        _renderTarget: function(target) {
            if (target && target !== "external") {
                this.$el.setAttribute("target", target);
            }
        }
    });
});
(function(exports, requirejs, define, document, XMLHttpRequest){

    /** ECMA SCRIPT COMPLIANT**/
    if (!String.prototype.trim) {
        String.prototype.trim = function () {
            return this.replace(/^\s+|\s+$/g, '');
        };
    }

    var underscore,
        Bus;

    /***
     * marks a function to be executed asycn
     * @return {*}
     */
    Function.prototype.async = function () {
        this._async = true;
        return this;
    };

    var xamlApplication = /^(xaml!)?(.+?)(\.xml)?$/;

    var Rewrite = function (from, to) {
            this.$from = from;
            this.$to = to;
        },
        defaultNamespaceMap = {
            "http://www.w3.org/1999/xhtml": "js.html",
            "http://www.w3.org/2000/svg": "js.svg"
        },
        defaultRewriteMap = [
            new Rewrite(/^js\/html\/(a)$/, "js/html/a"),
            new Rewrite(/^js\/html\/(input)$/, "js/html/Input"),
            new Rewrite(/^js\/html\/(select)$/, "js/html/Select"),
            new Rewrite(/^js\/html\/(textarea)$/, "js/html/TextArea"),
            new Rewrite(/^js\/html\/(option)$/, "js/html/Option"),
            new Rewrite(/^js\/html\/(.+)$/, "js/html/HtmlElement"),

            new Rewrite(/^js\/svg\/svg$/, "js/svg/Svg"),
            new Rewrite(/^js\/svg\/(.+)$/, "js/svg/SvgElement")
        ];

    if (typeof JSON !== "undefined") {
        define('JSON',[], function () {
            return JSON;
        });
    } else {
        requirejs.config({
            paths: {
                JSON: "js/lib/json2"
            },
            shim: {
                JSON: {
                    exports: "JSON"
                }
            }
        });
    }

    requirejs.config({
        paths: {
            json: "js/plugins/json"
        }
    });

    var rAppid = {

        createApplicationContext: function (mainClass, config, callback) {

            config = config || {};

            var internalCreateApplicationContext = function (config) {

                config.xamlClasses = config.xamlClasses || [];
                config.namespaceMap = config.namespaceMap || defaultNamespaceMap;
                config.rewriteMap = config.rewriteMap || defaultRewriteMap;

                var requirejsContext = requirejs.config(config),
                    applicationContext = new ApplicationContext(requirejsContext, config);

                define("rAppid", function () {
                    return applicationContext;
                });

                if (typeof JSON !== "undefined") {
                    define("JSON", function() {
                        return JSON;
                    });
                }

                requirejsContext(["inherit", "underscore", "js/core/Bus"], function (inherit, _, b) {
                    // we have to load inherit.js in order that inheritance is working
                    underscore = _;
                    Bus = b;

                    if (inherit && _) {

                        if (mainClass) {
                            //TODO: have a look at xamlClasses
                            var parts = xamlApplication.exec(mainClass);
                            if (parts) {
                                // mainClass is xaml
                                mainClass = "xaml!" + parts[2];
                            } else {
                                // mainClass is javascript factory
                                mainClass = mainClass.replace(/\./g, "/");
                            }

                            requirejsContext([mainClass], function (applicationFactory) {
                                applicationContext.$applicationFactory = applicationFactory;
                                callback(null, applicationContext);
                            }, function(err) {
                                callback(err);
                            });
                        } else {
                            callback(null, applicationContext);
                        }

                    } else {
                        callback("inherit or underscore missing");
                    }
                });

            };

            if (Object.prototype.toString.call(config) == '[object String]') {
                requirejs(["json!" + config], function (config) {
                    internalCreateApplicationContext(config);
                });
            } else {
                internalCreateApplicationContext(config);
            }

        },

        bootStrap: function (mainClass, config, callback) {
            rAppid.createApplicationContext(mainClass, config, function (err, applicationContext) {
                if (err || !document) {
                    callback(err || "target document missing");
                } else {
                    applicationContext.createApplicationInstance(document, callback);
                }
            })
        },

        rewriteMapEntry: Rewrite,

        createQueryString: function (parameter) {
            var ret = [];

            for (var key in parameter) {
                if (parameter.hasOwnProperty(key)) {
                    ret.push(encodeURIComponent(key) + "=" + encodeURIComponent(parameter[key]));
                }
            }

            return ret.join("&");
        },

        ajax: function (url, options, callback) {

            var s = {
                url: url
            };

            underscore.extend(s, rAppid.ajaxSettings, options);

            if (s.data && !underscore.isString(s.data)) {
                throw "data must be a string";
            }

            s.hasContent = !/^(?:GET|HEAD)$/.test(s.type);

            if (s.queryParameter && underscore.keys(s.queryParameter).length > 0) {
                // append query parameter to url
                s.url += /\?/.test(s.url) ? "&" : "?" + this.createQueryString(s.queryParameter);
            }

            // create new xhr
            var xhr = s.xhr();
            xhr.open(s.type, s.url, s.async);

            if (s.hasContent && s.contentType !== false) {
                xhr.setRequestHeader("Content-Type", s.contentType);
                xhr.setRequestHeader("Content-Length", s.data ? s.data.length.toString() : "0");
            }


            try {
                for (var header in s.headers) {
                    if (s.headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, s.headers[header]);
                    }
                }
            } catch (e) {
            } // FF3

            xhr.send(s.data);

            var xhrCallback = function (_, isAbort) {

                var wrappedXhr;

                if (xhrCallback && (isAbort || xhr.readyState === 4)) {
                    xhrCallback = undefined;

                    if (isAbort) {
                        // Abort it manually if needed
                        if (xhr.readyState !== 4) {
                            xhr.abort();
                        }
                    } else {
                        wrappedXhr = new rAppidXhr(xhr);
                    }

                    if (callback) {
                        callback(isAbort, wrappedXhr)
                    }
                }
            };

            if (!s.async || xhr.readyState === 4) {
                xhrCallback();
            } else {
                xhr.onreadystatechange = xhrCallback
            }

            return xhr;
        }
    };

    var rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg; // IE leaves an \r character at EOL

    var rAppidXhr = function (xhr) {
        this.xhr = xhr;
        this.status = xhr.status;
        this.$nativeResponseHeaders = xhr.getAllResponseHeaders();
        this.responses = {};

        var xml = xhr.responseXML;

        // Construct response list
        if (xml && xml.documentElement) {
            this.responses.xml = xml;
        }
        this.responses.text = xhr.responseText;

        try {
            this.statusText = xhr.statusText;
        } catch (e) {
            this.statusText = "";
        }
    };

    rAppidXhr.prototype.getResponseHeader = function (key) {
        var match;
        if (!this.$responseHeaders) {
            this.$responseHeaders = {};
            while (( match = rheaders.exec(this.$nativeResponseHeaders) )) {
                this.$responseHeaders[match[1].toLowerCase()] = match[2];
            }
        }
        return this.$responseHeaders[key.toLowerCase()];
    };


    rAppid.ajaxSettings = {
        type: "GET",
        contentType: "application/x-www-form-urlencoded",
        async: true,
        xhr: function () {
            return new XMLHttpRequest();
        },
        headers: {
        },
        data: null
    };

    var SystemManager = function (requirejsContext, applicationContext, document) {
        this.$requirejsContext = requirejsContext;
        this.$applicationContext = applicationContext;
        this.$applicationFactory = null;
        this.$document = document;
        this.$bus = new Bus();
    };

    var ApplicationContext = function (requirejsContext, config) {
        this.$requirejsContext = requirejsContext;
        this.$config = config;
    };

    ApplicationContext.prototype.createApplicationInstance = function (document, callback) {
            // create instance
            var applicationFactory = this.$applicationFactory;

            var systemManager = new SystemManager(this.$requirejsContext, this, document);

            this.$requirejsContext(["js/core/Application"], function (Application) {

                var application = new applicationFactory(null, false, systemManager, null, null);

                if (application instanceof Application) {

                    systemManager.$application = application;

                    application._initialize("auto");

                    // return rAppid instance
                    if (callback) {
                        callback(null, systemManager, application);
                    }

                } else {
                    var errMessage = "mainClass isn't an instance of js.core.Application";
                    if (callback) {
                        callback(errMessage);
                    } else {
                        throw(errMessage);
                    }
                }
            });

        };

    ApplicationContext.prototype.getFqClassName = function (namespace, className, useRewriteMap) {
            if (useRewriteMap == undefined || useRewriteMap == null) {
                useRewriteMap = true;
            }

            if (namespace && className) {
                namespace = (this.$config.namespaceMap[namespace] || namespace).replace(/\./g, '/');
                var fqClassName = [namespace, className].join("/");
            } else {
                fqClassName = (namespace || className).replace(/\./g, '/');
            }

            if (underscore.indexOf(this.$config.xamlClasses, fqClassName) !== -1) {
                fqClassName = 'xaml!' + fqClassName;
            }

            if (useRewriteMap) {
                for (var i = 0; i < this.$config.rewriteMap.length; i++) {
                    var entry = this.$config.rewriteMap[i];
                    if (entry instanceof rAppid.rewriteMapEntry) {
                        if (entry.$from.test(fqClassName)) {
                            return fqClassName.replace(entry.$from, entry.$to);
                        }
                    }
                }
            }

            return fqClassName;
        };

    ApplicationContext.prototype.createInstance = function (fqClassName, args, className) {
        args = args || [];

        var classDefinition;

        if (fqClassName instanceof Function) {
            classDefinition = fqClassName;
            fqClassName = classDefinition.prototype.constructor.name;
        } else {
            fqClassName = fqClassName.replace(/\./g, "/");
            classDefinition = this.$requirejsContext(fqClassName);
        }

        className = className || fqClassName;

        function construct(constructor, args) {
            function F() {
                return constructor.apply(this, args);
            }

            F.prototype = constructor.prototype;
            return new F();
        }

        var ret;
        try {
            ret = construct(classDefinition, args);
            ret.className = className;
        } catch (e) {
            console.log("Cannot create instance of '" + fqClassName + "'");
        }

        return ret;
    };

    ApplicationContext.prototype.ajax = function (url, options, callback) {

        if (!(/^http.*$/.test(url)) && this.$config.applicationUrl) {
            url = this.$config.applicationUrl + '/' + url;
        }

        rAppid.ajax(url, options, callback);
    };

    rAppid.defaultNamespaceMap = defaultNamespaceMap;
    rAppid.defaultRewriteMap = defaultRewriteMap;
    rAppid.SystemManager = SystemManager;
    rAppid.ApplicationContext = ApplicationContext;
    rAppid.Rewrite = Rewrite;

    exports.rAppid = rAppid;

}(  typeof exports !== "undefined" ? exports : window,
    typeof requirejs !== "undefined" ? requirejs : require('requirejs'),
    typeof requirejs !== "undefined" ? define : require('requirejs').define,
    typeof window !== "undefined" ? window.document : null,
    typeof window !== "undefined" ? window.XMLHttpRequest : require('xmlhttprequest').XMLHttpRequest));

define("js/lib/rAppid", function(){});

define('xaml',[], function () {
    var fs, createXhr,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        fetchXaml = function (url, callback) {
            throw new Error('Environment unsupported.');
        },
        buildMap = {},
        importRegEx = /((?:xaml!)?[a-z]+(\.[a-z]+[a-z0-9]*)*)/mgi;


    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (obj) {
            for (var i = 0; i < this.length; i++) {
                if (this[i] == obj) {
                    return i;
                }
            }
            return -1;
        }
    }

    /**
     * IE8 FIXES
     * @param domNode
     */
    var localNameFromDomNode = function (domNode) {
        if (domNode.localName) return domNode.localName;

        var st = domNode.tagName.split(":");
        return st[st.length - 1];
    };

    function hasContent(string) {
        return /\S/.test(string);
    }

    function getDependency(namespace, localName, namespaceMap, xamlClasses, rewriteMap) {

        namespaceMap = namespaceMap || {};
        rewriteMap = rewriteMap || {};
        xamlClasses = xamlClasses || [];

        namespace = (namespaceMap[namespace] || namespace).replace(/\./g, '/');
        var fqClassName = [namespace, localName].join("/");


        for (var i = 0; i < rewriteMap.length; i++) {
            var entry = rewriteMap[i];
            if (entry.$from && entry.$to) {
                if (entry.$from.test(fqClassName)) {
                    fqClassName = fqClassName.replace(entry.$from, entry.$to);

                    break;
                }
            }
        }

        if (xamlClasses.indexOf(fqClassName) !== -1) {
            fqClassName = "xaml!" + fqClassName;
        }

        return fqClassName.replace(/\./g, "/");
    }

    function getTextContentFromNode(a) {
        var b = a.textContent || a.text || a.data;
        if (!b) {
            b = "";
            for (var c = 0; c < a.childNodes.length; c++) {
                var d = a.childNodes[c];
                if (d.nodeType == 1 || d.nodeType == 4) b += this._getTextContentFromDescriptor(d);
            }
        }
        return b;
    }

    function findDependencies(xaml, namespaceMap, xamlClasses, rewriteMap, imports) {

        var ret = [];

        function findDependencies(domNode) {

            var localName = localNameFromDomNode(domNode);

            var dep = getDependency(domNode.namespaceURI, localName, namespaceMap, xamlClasses, rewriteMap);
            // console.log(dep);
            if (dep == "js/core/Imports") {
                for (var t = 0; t < domNode.childNodes.length; t++) {
                    var importNode = domNode.childNodes[t];
                    if (importNode.nodeType == 3) {
                        // text node
                        var m;

                        var textContent = getTextContentFromNode(importNode);
                        while ((m = importRegEx.exec(textContent + " ")) != null) {
                            var importClass = m[0].replace(/\./g, "/");
                            if (importClass !== "undefined") {
                                if (ret.indexOf(importClass) == -1) {
                                    ret.push(importClass);
                                }

                                if (imports) {
                                    imports.push(importClass);
                                }
                            }
                        }
                    }
                }
            }

            if (ret.indexOf(dep) == -1) {
                ret.push(dep);
            }

            for (var i = 0; i < domNode.childNodes.length; i++) {
                var childNode = domNode.childNodes[i];
                // element
                if (childNode.nodeType == 1) {
                    findDependencies(childNode);
                }
            }

        }

        if (xaml) {
            findDependencies(xaml);
        }

        return ret;
    }

    function findScripts(xaml, namespaceMap, xamlClasses, rewriteMap) {
        var ret = [];

        for (var i = 0; i < xaml.childNodes.length; i++) {
            var node = xaml.childNodes[i];
            if (node.nodeType == 1) {
                if ("js/core/Script" == getDependency(node.namespaceURI, localNameFromDomNode(node), namespaceMap, xamlClasses, rewriteMap)) {
                    ret.push(node);
                }
            }
        }

        return ret;
    }

    function getDeclarationFromScripts(scripts) {
        var ret = {};

        if (scripts) {
            for (var s = 0; s < scripts.length; s++) {
                var script = scripts[s];
                for (var fn in script) {
                    if (script.hasOwnProperty(fn)) {
                        ret[fn] = script[fn];
                    }
                }
            }
        }

        return ret;
    }

    if ((typeof window !== "undefined" && window.navigator && window.document) || typeof importScripts !== "undefined") {
        // Browser action
        createXhr = function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else {
                for (i = 0; i < 3; i++) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {
                    }

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            if (!xhr) {
                throw new Error("getXhr(): XMLHttpRequest not available");
            }

            return xhr;
        };

        fetchXaml = function (url, callback) {
            var xhr;

            try {
                xhr = createXhr();
                xhr.open('GET', url, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.responseXML) {
                            callback(null, xhr.responseXML);
                        } else {
                            callback("no responseXML found");
                        }
                    }
                };
                xhr.send(null);
            } catch (e) {
                callback(e);
            }
        };
        // end browser.js adapters
    } else if (typeof process !== "undefined" && process.versions && !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        fetchXaml = function (path, callback) {
            try {
                var content = fs.readFileSync(path, 'utf8');
                callback(null, require.nodeRequire('libxml').parseFromString(content));
            } catch (e) {
                callback(e);
            }
        };
    }


    return {

        write: function (pluginName, name, write) {

            if (name in buildMap) {
                var text = buildMap[name];
                write.asModule(pluginName + "!" + name, text);
            }
        },

        version: '0.2.0',

        load: function (name, parentRequire, load, config) {

            var url = parentRequire.toUrl(name + ".xml");

            fetchXaml(url, function (err, xml) {
                if (!err && xml) {

                    // require all dependencies
                    var imports = [],
                        importStartIndex = 1;

                    var dependencies = findDependencies(xml.documentElement,
                        config.namespaceMap, config.xamlClasses, config.rewriteMap, imports);

                    var scripts = findScripts(xml.documentElement,
                        config.namespaceMap, config.xamlClasses, config.rewriteMap);

                    if (scripts.length > 1) {
                        throw "only one script block allowed in XAML";
                    }

                    if (scripts.length > 0) {
                        // at least one script
                        dependencies.splice(1, 0, "js/core/Script");
                        importStartIndex++;
                    }

                    if (imports.length > 0) {
                        // add imports after start index
                        dependencies = dependencies.slice(0, importStartIndex)
                            .concat(imports)
                            .concat(dependencies.slice(importStartIndex));
                    }

                    if (config.isBuild) {
                        console.log(dependencies);
                        dependencies.splice(1, 0, "js/core/Element");
                        importStartIndex++;

                        var text = "(function () {define(%dependencies%, %function%)}).call(this);";
                        var fn = "function(baseClass, ELEMENT %parameter%){return baseClass.inherit({ %classDefinition% _$descriptor: ELEMENT.xmlStringToDom(%descriptor%)})}";

                        for (var i = 0; i < dependencies.length; i++) {
                            dependencies[i] = "'" + dependencies[i] + "'";
                        }

                        text = text.replace('%dependencies%', '[' + dependencies.join(',') + ']');

                        var xmlContent = xml.documentElement.toString()
                            .replace(/((\r\n|\n|\r)[\s\t]*)/gm, "")
                            .replace(/'/g, "\\'")
                            .replace(/<js:Script[^>]*>[\s\S]*<\/js:Script[^>]*>/, "");

                        var parameter = "",
                            classDefinition = "";

                        if (scripts.length > 0) {
                            var script = scripts[0].toString();

                            var rScriptExtractor = /^[\s\S]*?function\s*\(([\s\S]*?)\)[\s\S]*?\{[\s\S]*?return[\s\S]*?\{([\s\S]*)\}[\s\S]*?\}[\s\S]*?\)[^)]*$/;
                            var result = rScriptExtractor.exec(script);

                            if (result) {
                                // get parameter and trim
                                if (hasContent(result[1])) {
                                    // add comma for separate from baseClass
                                    parameter = ",SCRIPT," + result[1];
                                }

                                if (hasContent(result[2])) {
                                    classDefinition = result[2] + ','
                                }

                            } else {
                                throw "Error parsing script block";
                            }

                        }

                        fn = fn.replace('%parameter%', parameter);
                        fn = fn.replace('%classDefinition%', classDefinition);
                        fn = fn.replace('%descriptor%', "'" + xmlContent + "'");

                        text = text.replace('%function%', fn);

                        load.fromText(name, text);

                        buildMap[name] = text;

                        parentRequire([name], function (value) {
                            load(value);
                        });
                    } else {
                        // first item should be the dependency of the document element
                        parentRequire(dependencies, function (value) {

                            // dependencies are loaded
                            var baseClass = arguments[0],
                                Script = arguments[1];

                            var args = Array.prototype.slice.call(arguments);

                            var scriptObjects = [];
                            var importedClasses = args.slice(importStartIndex);

                            if (scripts.length > 0) {
                                for (var s = 0; s < scripts.length; s++) {
                                    try {
                                        var scriptInstance = new Script(null, scripts[s]);
                                        scriptObjects.push(scriptInstance.evaluate(importedClasses));
                                    } catch (e) {
                                        load.error(new Error(name + ": Script cannot be loaded" + e));
                                    }
                                }
                            }

                            var xamlFactory = baseClass.inherit(
                                getDeclarationFromScripts(scriptObjects)
                            );

                            xamlFactory.prototype._$descriptor = xml.documentElement;

                            load(xamlFactory);
                        }, function(err) {
                            load.error(err);
                        });
                    }
                } else {
                    load.error(new Error("XML " + url + " not found." + err));
                }
            });
        }
    }
});



define('json',['JSON'], function (JSON) {
    var fs, createXhr,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        fetchJSON = function (url, callback) {
            throw new Error('Environment unsupported.');
        },
        buildMap = {},
        rSuffix = /^(.+)\.json$/i;


    if ((typeof window !== "undefined" && window.navigator && window.document) || typeof importScripts !== "undefined") {
        // Browser action
        createXhr = function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else {
                for (i = 0; i < 3; i++) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch(e) {
                    }

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            if (!xhr) {
                throw new Error("getXhr(): XMLHttpRequest not available");
            }

            return xhr;
        };

        fetchJSON = function (url, callback) {
            var xhr;

            try {
                xhr = createXhr();
                xhr.open('GET', url, true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.responseText) {
                            callback(null, xhr.responseText);
                        } else {
                            callback("no responseXML found");
                        }
                    }
                };
                xhr.send(null);
            } catch(e) {
                callback(e);
            }
        };
        // end browser.js adapters
    } else if (typeof process !== "undefined" && process.versions && !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        fetchJSON = function (path, callback) {
            try {
                var content = fs.readFileSync(path, 'utf8');
                callback(null, content);
            } catch(e) {
                callback(e);
            }
        };
    }


    return {

        write: function (pluginName, name, write) {

            if (name in buildMap) {
                var text = buildMap[name];
                write.asModule(pluginName + "!" + name, text);
            }
        },

        version: '0.1.0',

        load: function (name, parentRequire, load, config) {


            name = name.replace(rSuffix,"$1");
            name = name + ".json";

            var url = parentRequire.toUrl(name );

            fetchJSON(url, function (err, raw) {
                if (!err) {
                    load(JSON.parse(raw));
                } else {
                    load.error(new Error("Json for " + url + " not found"));
                }
            });
        }
    }
});


